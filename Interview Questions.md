
> 说一说序列化怎么做以及为什么要序列化

其实序列化最终的目的是为了对象可以跨平台存储，和进行网络传输。而我们进行跨平台存储和网络传输的方式就是IO，我们的IO支持的数据格式就是字节数组。

因为我们单方面的只把对象转成字节数组还不行，因为没有规则的字节数组我们是没办法把对象的本来面目还原回来的

我们必须在把对象转成字节数组的时候就制定一种规则（序列化），那么我们从IO流里面读出数据的时候再以这种规则把对象还原回来（反序列化）。

只需要实现Serializable 接口即可


> 线程交替打印奇数偶数

> TreeMap怎么按照自己想要的顺序排序

> ConcurrentHashMap怎么取的size值

JDK1.7 和 JDK1.8 对 size 的计算是不一样的。 1.7 中是先不加锁计算三次，如果三次结果不一样在加锁。
JDK1.8 size 是通过对 baseCount 和 counterCell 进行 CAS 计算，最终通过 baseCount 和 遍历 CounterCell 数组得出 size。

JDK1.8中使用一个volatile类型的变量baseCount记录元素的个数，当插入新数据put()或则删除数据remove()时，会通过addCount()方法更新baseCount:

初始化时counterCells为空，在并发量很高时，如果存在两个线程同时执行CAS修改baseCount值，则失败的线程会继续执行方法体中的逻辑，执行fullAddCount(x, uncontended)方法，这个方法其实就是初始化counterCells，并将x的值插入到counterCell类中，而x值一般也就是1


所以counterCells存储的都是value为1的CounterCell对象，而这些对象是因为在CAS更新baseCounter值时，由于高并发而导致失败，最终将值保存到CounterCell中，放到counterCells里。这也就是为什么sumCount()中需要遍历counterCells数组，sum累加CounterCell.value值了。


> string为什么要用final修饰？

* 当String支持非可变性的时候，它们的值很好确定，不管调用哪个方法，都互不影响。HashSet用StringBuilder做元素的场景
* String 另外一个字符串常量池的属性。像下面这样字符串 one 和 two 都用字面量 "something" 赋值。它们其实都指向同一个内存地址。
*  因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的
*  因为字符串是不可变的，所以在它创建的时候HashCode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键

> final和static的作用。

> java中==和equals和hashCode的区别，重写euqals需要重写hash吗

`==`
1.若是基本数据类型比较，是比较值，
2.若是引用类型，则比较的是他们在内存中存放的地址。
对象是放在堆中，栈中存放的对象的引用，所以==是对栈中的值进行比较，若返回true，代表变量的内存地址相等

* equals() 定义在JDK的Object.java中。Object类的equals方法用于判断对象的内存地址引用是不是同一个地址。若是 类中覆盖了equals方法，就要根据具体代码来确定
  * 使用默认的“equals()”方法，等价于“==”方法
  * 若是类中覆盖了equals方法，就要根据具体代码来确定，一般覆盖后都是通对象的内容是否相等来判断对象是否相等
* hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。
  * 因为Hash比equals方法的开销要小，速度更快，所以在涉及到hashcode的容器中（比如HashSet），判断自己是否持有该对象时，会先检查hashCode是否相等，如果hashCode不相等，就会直接认为不相等，并存入容器中，不会再调用equals进行比较

* 如果你重写了equals，比如说是基于对象的内容实现的，而保留hashCode的实现不变，那么很可能某两个对象明明是“相等”，而hashCode却不一样

> int、char、long各占多少字节数


> int与integer的区别
> 对java多态的理解
> 抽象类和接口区别
> 抽象类与接口的应用场景
> 抽象类是否可以没有方法和属性？
> 泛型中extends和super的区别
> 静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？

不能，父类的静态方法能够被子类继承，但是不能够被子类重写，即使子类中的静态方法与父类中的静态方法完全一样，也是两个完全不同的方法

* 实际上，子类的静态方法隐藏了父类的静态方法，因此父类的子类的静态方法同时存在，只不过父类通过类名（或对象名）调用的是父类的静态方法，子类通过类名（或对象名）调用的是子类的静态方法

> 静态内部类的设计意图

非静态内部类有一个很大的优点：可以自由使用外部类的所有变量和方法

静态内部类的作用：只是为了降低包的深度，方便类的使用，
* 静态内部类适用于包含类当中，但又不依赖与外在的类，不用使用外在类的非静态属性和方法，只是为了方便管理类结构而定义。在创建静态内部类的时候，不需要外部类对象的引用
* 因为这个类没有必要单独存放一个文件，它一般来说只被所在外部类使用。并且它可以直接被用 外部类名+内部类名

> 内部类的作用
Java内部类
* 成员内部类: 成员内部类可以看成是外部类的一个成员，在成员内部类中无法声明静态成员,持有外部类当前对象的引用
* 局部内部类: 局部内部类定义在外部类的方法中，就像局部变量一样，并不是外部类的成员。局部内部类在方法外是无法访问到的
* 匿名内部类:没有类名的局部内部类,不能有构造器,匿名内部类必须继承或实现一个接口
* 静态内部类:静态内部类不会持有外部类当前对象的引用，所以在静态内部类中无法访问外部类的非静态成员



> string 转换成 integer的方式及原理
* `integer.parseInt(string str)`方法调用Integer内部的`parseInt(string str,10)`方法,默认基数为10，
* parseInt内部首先判断字符串是否包含符号（-或者+），则对相应的negative和limit进行
* 赋值，然后再循环字符串，对单个char进行数值计算Character.digit(char ch, int radix)
* 在这个方法中，函数肯定进入到0-9字符的判断（相对于string转换到int），
* 否则会抛出异常，数字就是如上面进行拼接然后生成的int类型数值


> 说说你对Java反射的理解

Java反射机制允许程序在运行时透过`Reflection API`s取得任意一个已知名称的class的内部信息，
* 包括modifiers(如public、static等)
* superclass(如Object)
* 实现的interfaces(如Serializable)
* fields(属性)和methods(方法)(但不包括methods定义)，可于运行时改变fields的内容，也可调用methods


* 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在Jvm的方法区内，
* 然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。
* 类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口



# Collections
> List的线程安全类
* java.util.Collections.SynchronizedList： 把所有 List 接口的实现类转换成线程安全的List 
* CopyOnWriteArrayList
  * 在高并发情况下，读取元素时就不用加锁，写数据时才加锁，大大提升了读取性能 

> ArrayList的扩容 

* 底层是`transient Object[] elementData`;
* 底层其实是调用了`Arrays.copyOf`方法来进行扩充数组容量的
* 如果通过无参构造的话，初始数组容量为0，当真正对数组进行添加时（即添加第一个元素时），才真正分配容量，
* 默认分配容量为10；当容量不足时（容量为size，添加第size+1个元素时），先判断按照1.5倍（位运算）的比例扩容能否满足最低容量要求，若能，则以1.5倍扩容，否则以最低容量要求进行扩容
 * 一般情况下，如果扩容1.5倍后就大于期望容量，那就返回这个1.5倍旧容量的值。而如果小于期望容量，那就返回期望容量。这里对默认容量10做了特殊处理
 * 使用1.5倍这个数值而不是直接使用期望容量，是为了防止频繁扩容影响性能。试想如果每次add操作都要扩容一次，那性能将会非常低下

* 执行add(E e)方法时，先判断ArrayList当前容量是否满足size+1的容量；
* 在判断是否满足size+1的容量时，先判断ArrayList是否为空，若为空，则先初始化ArrayList初始容量为10，
* 再判断初始容量是否满足最低容量要求；若不为空，则直接判断当前容量是否满足最低容量要求；若满足最低容量要求，则直接添加；若不满足，则先扩容，再添加。


## HashMap 
> HashMap 原理

先从HashMap的结构开始吧，
* HashMap是一种散列表，以Key/Value形式存储，Key和Value都可以为空，在JDK 1.7时是由数组+链表组成，JDK 1.8则由数组+链表+红黑树组成，
* 这里主要介绍下JDK 1.8版本的HashMap，初始默认的容量是16，负载因子是0.75，当链表上的元素大于8 且数组容量大于64时链表进行红黑树化，当红黑树上元素减少到6时，红黑树会退化为链表。
* 数组的查询效率是O(1),链表的查询效率是O(N)，红黑树的查询效率是O(logN)。
HashMap的容量必须是2的次幂，
* 在构造方法中传入的容量如果不是2的次幂，那么HashMap会调用tableSizeFor()方法来获取一个最接近传入容量且大于传入容量的2的次幂的值，比如传入的容量是17则tableSizeFor()会返回32
* HashMap空参数的构造方法创建出来的HashMap对象是不会初始化空间的，当使用空参构造方法创建出对象后，HashMap将在第一次插入元素时进行空间的初始化

HashMap主要有2个重要方法，put()/get()，put()方法就是将元素无序的加入到HashMap中，也就是无法保证元素的插入顺序，get方法就是获取HashMap中的元素
* 当元素进行put时，首先要计算key的Hash值，为了更加分散，获取hash值后，HashMap会让hash值的高16位与hash进行异或

> 如果查询多，插入少，怎么改进HashMap
> HashMap源码理解
> HashMap怎么手写实现？

>HashMap 扩容

* HashMap的扩容会调用resize()方法，扩容阈值为当前容量 * 负载因子，
* 如果默认情况下hashMap容量为16，负载因子是0.75，则元素个数大于12就会触发扩容，
* resize()先判断HashMap是不是初始化了，扩容的时候会创建一个新的数组，然后旧数组中的元素进行搬移，JDK1.7 的HashMap在并发场景下扩容有可能会造成死循环，cpu飙升100%



> 扩容的过程
1.引用旧的entry数组
2.遍历旧的entry数组
3.获得每个元素
4.去掉旧数组对象的引用
5.重新计算每个元素在数组中的位置
6.标记并放入新数组中
7.访问下一个元素


> 红黑树和链表的转化

* 初始默认的容量是16，负载因子是0.75，当链表上的元素大于8 且数组容量大于64时链表进行红黑树化，当红黑树上元素减少到6时，红黑树会退化为链表

> ConcurrentHashMap的实现原理
在jdk1.7中是采用Segment + HashEntry + ReentrantLock的方式进行实现的，

> ConcurrentHashMap 1.8优化
而1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现。
* synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。
* 利用一个CAS算法实现无锁化的修改值的操作，他可以大大降低锁代理的性能消耗




> TreeMap具体实现
* TreeMap是一个有序的key-value集合，是非线程安全的，基于红黑树（Red-Black tree）实现。
* 其映射根据键的自然顺序进行排序，或者根据创建映射时提供的Comparator 进行排序，具体取决于使用的构造方法
> HashMap与HashSet的区别
它们都必须计算hashcode，但请考虑HashMap键的性质--它通常是一个简单的String，甚至是一个Integer。计算它的hashcode要比整个对象的默认hashcode计算快得多。如果HashMap的键与存储在HashSet中的键是同一个对象，那么在性能上就不会有真正的差别。区别在于HashMap的键是什么类型的对象

>HashSet与HashMap怎么判断集合元素重复？
* HashMap中的Key是根据对象的hashCode() 和 euqals()来判断是否唯一的。



# Java 8
> Stream实现原理
