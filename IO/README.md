- I/O的底层实现
- 操作系统的基本概念
 -  I/O过程
- I/O 模型
 - 同步，异步
 - 阻塞，非阻塞  
- I/O的分类
 - BIO
 - NIO
 - IO复用
 - AIO回去 
---
# I/O 

接触最多的就是 磁盘 IO（读写文件） 和 网络 IO（网络请求和响应）

无论是 Socket 的读写还是文件的读写，在 Java 层面的应用开发或者是 linux 系统底层开发，都属于输入 input 和输出 output 的处理，简称为 IO 读写


## 操作系统的基本概念

* 操作系统： 控制和管理整个计算机系统的硬件和软件资源，并合理的组织调度计算机的工作和资源的分配， 以提供用户和其他软件方便的接口和和环境，它是计算机系统中最基本的系统软件。

* 内核：操作系统的核心软件，负责管理系统的进程、内存、设备驱动程序、文件和网络系统等等，为应用程序提供对计算机硬件的安全访问服务



为了避免用户进程直接操作内核，保证内核安全，操作系统将内存寻址空间划分为两部分
* 内核空间（Kernel-space），供内核程序使用 
* 用户空间（User-space）： 供用户进程使用 为了安全，内核空间和用户空间是隔离的，即使用户的程序崩溃了，内核也不受影响

* 抽象数据流(I/O流)的概念：指一组有顺序的、有起点和终点的字节集合


## I/O 过程

> write 把数据从进程缓冲区复制到内核缓冲区，它们不等价于数据在内核缓冲区和磁盘之间的交换

用户程序进行 IO 的读写，基本上会用到系统调用 read&write

> 内核缓冲与进程缓冲区

缓冲区的目的，是为了减少频繁的系统 IO 调用
* 系统内核也有个缓冲区叫做内核缓冲区。
* 每个进程有自己独立的缓冲区，叫做进程缓冲区。


* read 把数据从内核缓冲区复制到进程缓冲区
  * read 系统调用，并不是把数据直接从物理设备，读数据到内存。
  * read 系统调用，是把数据从内核缓冲区复制到进程缓冲区；
* write 把数据从进程缓冲区复制到内核缓冲区
  * write 系统调用，也不是直接把数据，写入到物理设备 
  * write 系统调用，是把数据从进程缓冲区复制到内核缓冲区

<img width="546" alt="Screen Shot 2021-12-18 at 4 20 01 PM" src="https://user-images.githubusercontent.com/27160394/146634657-53194294-ef4e-4706-9109-e026dcc6b2ec.png">

1. 客户端请求，Linux通过网卡，读取客户不断的请求数据，将数据读取到内核缓冲区
2. 获取请求数据，服务器从内核缓冲区读取数据到 Java 进程缓冲区。
3. 服务器端业务处理，Java 服务端在自己的用户空间中，处理客户端的请求。
4. 服务器端返回数据，Java 服务端已构建好的响应，从用户缓冲区写入系统缓冲区。
5. 发送给客户端，Linux 内核通过网络 I/O ，将内核缓冲区中的数据，写入网卡，网卡通过底层的通讯协议，会将数据发送给目标客户端。


从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。

* 为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 用户空间（User space） 和 内核空间（Kernel space ） 。
* 像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。
  * 我们想要进行 IO 操作，一定是要依赖内核空间的能力
  * 用户空间的程序不能直接访问内核空间
* 当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。
    * 因此，用户进程想要执行 IO 操作的话，必须通过 系统调用 来间接访问内核空间
    * 操作系统负责的内核执行具体的 IO 操作
    * 我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的


当应用程序发起 I/O 调用后，会经历两个步骤：
* 内核等待 I/O 设备准备好数据
* 内核将数据从内核空间拷贝到用户空间。

> 那么阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息


# I/O 模型

## 阻塞式 I/O
> 应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回

当进行IO读写时，线程是阻塞的状态。此时会让出cpu控制权，不会占用cpu资源
* 阻塞是指用户空间（调用线程）一直在等待，而且别的事情什么都不做
* 在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞
* 用户空间线程是主动发起 IO 请求的一方，内核空间是被动接受方
* 阻塞状态不会占用CPU，但是会发生线程的切换，线程切换时会有上下文保存转换的过程，需要CPU调度，是一个很昂贵的操作

<img width="369" alt="Screen Shot 2021-12-18 at 5 55 51 PM" src="https://user-images.githubusercontent.com/27160394/146636974-30449026-0e1e-44cb-97ae-22c0406b2be2.png">

## 非阻塞式 I/O

在进行IO操作的时候，如果设备还未准备好（比如socket还没有收到数据），操作会直接返回结果，不会让当前线程进入阻塞状态


<img width="351" alt="Screen Shot 2021-12-18 at 5 56 32 PM" src="https://user-images.githubusercontent.com/27160394/146636990-0e2b6372-ca5f-4be3-9ec9-46fd9ade0056.png">


> 阻塞IO 和 非阻塞IO

当线程访问资源时，该资源是否准备就绪的一种处理方式。若线程访问时，资源未准备就绪，线程什么也不做，就一直等待着资源就绪，这种处理方法就叫阻塞。但如果资源是不一直等待该资源，而是去做其他事情，那就是非阻塞

* 程序级别的
* `read`函数是操作系统提供的，而且是阻塞的，我们叫它 阻塞 IO, 非阻塞的 read，指的是在数据到达前，即数据还未到达网卡，或者到达网卡但还没有拷贝到内核缓冲区之前，这个阶段是非阻塞的。
* 程序请求操作系统IO操作后，如果IO资源没有准备好，那么程序该如何处理的问题
* 阻塞是等待,非阻塞继续执行，并且使用线程一直轮询，直到有IO资源准备好了


### 异步IO：

* 读写IO时仅发出请求，然后立即执行后续代码
* 代码编写复杂，CPU执行效率高
* JDK提供的`java.nio`是异步IO

<img width="370" alt="Screen Shot 2021-12-18 at 5 58 04 PM" src="https://user-images.githubusercontent.com/27160394/146637025-b61c9632-a1d0-4786-8040-8101abe4024a.png">


### 同步IO：

* 读写IO时代码等数据返回后才继续执行后续代码
* 代码编写简单，CPU执行效率低
* JDK提供的`java.io`是同步IO


> 同步IO 和 非同步IO

同步和异步是访问数据的机制。
*  操作系统级别的
*  同步 I/O: 应用进程在调用 recvfrom 操作时会阻塞。调用者一旦开始调用方法，则必须等待调用方法的结果返回后，才能去做其他事。
*  异步 I/O: 不会阻塞。调用更像一个消息传递，调用一开始，方法调用马上就会返回，让调用者可以继续后续的操作
*  操作系统在收到程序请求IO操作后，如果IO资源没有准备好，该如何响应程序的问题: 
  *  同步IO不响应，直到IO资源准备好以后；
  *  非同步IO返回一个标记(好让程序和自己知道以后的数据往哪里通知)，当IO资源准备好以后，再用事件机制返回给程序。


* 阻塞/非阻塞：关注的是程序(线程)等待消息通知时的状态。
* 同步/异步：关注的是消息通知的机制。每个 IO 事件的通知等待是异步，主动打听是同步




# Java 中 4 种常见 IO 模型

![image](https://user-images.githubusercontent.com/27160394/144961570-fcd22eae-a64a-42aa-b549-bb5782ff3c82.png)


同步阻塞IO（BIO）：用户进程发起一个IO操作以后，必须等待IO操作的真正完成后，才能继续运行；

同步非阻塞IO（NIO）：用户进程发起一个IO操作以后，可做其它事情，但用户进程需要经常询问IO操作是否完成，这样造成不必要的CPU资源浪费；

异步非阻塞IO（AIO）：用户进程发起一个IO操作然后，立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知。类比Future模式。



## BIO (Blocking I/O)
> 属于同步阻塞 IO 模型, Java BIO是传统的Java io编程，相关的类和接口在`java.io`包中


用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间


<img width="305" alt="Screen Shot 2021-12-13 at 3 49 42 PM" src="https://user-images.githubusercontent.com/27160394/145772604-3d19fd8e-1026-47e1-b894-6b7bf861857a.png">


1.  当用户线程调用了read系统调用,内核(kernel)就开始了 IO 的第一个阶段：准备数据.数据在一开始还没有到达（比如，还没有收到一个完整的 Socket 数据包),这个时候 kernel就要等待足够的数据到来。
2. 当 kernel 一直等到数据准备好了，它就会将数据从 kernel 内核缓冲区，拷贝到用户缓冲区（用户内存），然后 kernel 返回结果。
3. 从开始 IO 读的 read 系统调用开始，用户线程就进入阻塞状态。一直到kernel返回结果后，用户线程才解除 block 的状态，重新运行起来。

所以，blocking IO 的特点就是在内核进行 IO 执行的两个阶段，用户线程都被block了。

### 优缺点
* 程序简单，在阻塞等待数据期间，用户线程挂起。用户线程基本不会占用 CPU 资源
* 每个连接配套一条独立的线程，或者说一条线程维护一个连接成功的 IO 流的读写，BIO 模型在高并发场景下是不可用的。


## NIO (Non-blocking/New I/O)
> Java 中的 NIO 可以看作是 I/O 多路复用模型。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型

应用程序会一直发起read调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间

* 在内核缓冲区没有数据的情况下，系统调用会立即返回，返回一个调用失败的信息。
```
真正的非阻塞 IO，不能是通过我们用户层的小把戏，而是要恳请操作系统为我们提供一个非阻塞的 read 函数。
这个 read 函数的效果是，如果没有数据到达时（到达网卡并拷贝到了内核缓冲区），立刻返回一个错误值（-1），而不是阻塞地等待。
```

* 在内核缓冲区有数据的情况下，是阻塞的，直到数据从内核缓冲复制到用户进程缓冲。
```
非阻塞的 read，指的是在数据到达前，即数据还未到达网卡，或者到达网卡但还没有拷贝到内核缓冲区之前，这个阶段是非阻塞的。
当数据已到达内核缓冲区，此时调用 read 函数仍然是阻塞的，需要等待数据从内核缓冲区拷贝到用户缓冲区，才能返回。
```

<img width="375" alt="Screen Shot 2021-12-13 at 3 51 13 PM" src="https://user-images.githubusercontent.com/27160394/145772772-4403a338-3352-4695-9582-098057d5a7d7.png">


1. 在内核数据没有准备好的阶段，用户线程发起 IO 请求时，立即返回。用户线程需要不断地发起 IO 系统调用。
2. 内核数据到达后，用户线程发起系统调用，用户线程阻塞。内核开始复制数据。它就会将数据从 kernel 内核缓冲区，拷贝到用户缓冲区（用户内存），然后 kernel 返回结果。
3. 用户线程才解除 block 的状态，重新运行起来。经过多次的尝试，用户线程终于真正读取到数据，继续执行

```
客户端和服务器之间通过Channel通信。
* NIO可以在Channel进行读写操作。这些Channel都会被注册在Selector多路复用器上。
* Selector通过一个线程不停的轮询这些Channel。找出已经准备就绪的Channel执行IO操作。 
* NIO 通过一个线程轮询，实现千万个客户端的请求，这就是非阻塞NIO的特点
```

所以 NIO 的特点是应用程序的线程需要不断的进行 I/O 系统调用，轮询数据是否已经准备好，如果没有准备好，继续轮询，直到完成系统调用为止。

### NIO 的优缺点：
* 每次发起的 IO 系统调用，在内核的等待数据过程中可以立即返回。用户线程不会阻塞，实时性较好
* 需要不断的重复发起 IO 系统调用，这种不断的轮询，将会不断地询问内核，这将占用大量的 CPU 时间，系统资源利用率较低

----

## 多路复用 I/O
> Java NIO(New IO)不是 IO 模型中的 NIO 模型，而是IO多路复用模型（IO multiplexing）

<img width="336" alt="Screen Shot 2021-12-18 at 5 57 18 PM" src="https://user-images.githubusercontent.com/27160394/146637005-1057cb96-6b75-486b-9abb-ed025590df77.png">

经典的Reactor设计模式，有时也称为`异步阻塞IO` 
* 我们可以每 accept 一个客户端连接后，将这个文件描述符（connfd）放到一个数组里
* IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，
* 等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间->用户空间）还是阻塞的



多路复用避免同步非阻塞 NIO 模型中轮询等待的问题
* 通过一种新的系统调用，一个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是内核缓冲区可读/可写），内核 kernel 能够通知程序进行相应的 IO 系统调用
 *  操作系统提供给我们一个有这样效果的函数，我们将一批文件描述符通过一次系统调用传给内核，由内核层去遍历，才能真正解决这个问题。
* 使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用`recvfrom`把数据从内核复制到进程中
* 目前支持 IO 多路复用的系统调用，有 select，epoll 


IO 多路复用模型的基本原理就是 select/epoll 系统调用，单个线程不断的轮询select/epoll 系统调用所负责的成百上千的 socket 连接，当某个或者某些 socket 网络连接有数据到达了，就返回这些可以读写的连接

1. 进行`select/epoll`系统调用，查询可以读的连接。Kernel 会查询所有 select的可查询 socket 列表，当任何一个 socket 中的数据准备好了，select 就会返回。当用户进程调用了select，那么整个线程会被 block（阻塞掉）。
2. 用户线程获得了目标连接后，发起 read 系统调用，用户线程阻塞。内核开始复制数据。它就会将数据从 kernel 内核缓冲区，拷贝到用户缓冲区（用户内存），然后 kernel 返回结果。
3. 用户线程才解除 block 的状态，用户线程终于真正读取到数据，继续执行。


所以多路复用 IO 的特点，IO 多路复用模型，建立在操作系统 kernel 内核能够提供的多路分离系统调用 select/epoll 基础之上的。
* 多路复用 IO 需要用到两个系统调用（system call）
  *  一个 select/epoll 查询调用
  *  一个是 IO 的读取调用。
  


<img width="374" alt="Screen Shot 2021-12-13 at 3 52 14 PM" src="https://user-images.githubusercontent.com/27160394/145772887-3f2b13e2-075d-4174-aa90-8b3914e5d880.png">



多路复用 IO 的优点：
* 用 select/epoll 的优势在于，它可以同时处理成千上万个连接。与一条线程维护一个连接相比， I/O 多路复用技术的最大优势是：**系统不必创建线程，也不必维护这些线程，从而大大减小了系统的开销。
* 本质上，select/epoll 系统调用，属于同步 IO，也是阻塞 IO。都需要在读写事件就绪后，自己负责进行读写，也就是说这个读写过程是阻塞的

```
目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用
* select 调用 ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。 
* epoll 调用 ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。

```

Java 中的 NIO ，有一个非常重要的选择器 ( Selector ) 的概念，也可以被称为 多路复用器。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务

<img width="341" alt="Screen Shot 2021-12-13 at 3 55 23 PM" src="https://user-images.githubusercontent.com/27160394/145773306-e07261a3-553d-4e7e-b4e1-9ef835c95047.png">


### 多路复用 IO 的优缺点：
* 用 select/epoll 的优势在于，它可以同时处理成千上万个连接。与一条线程维护一个连接相比，
* 统不必创建线程，也不必维护这些线程，从而大大减小了系统的开销。
* 本质上，select/epoll 系统调用，属于同步 IO，也是阻塞 IO。都需要在读写事件就绪后，自己负责进行读写，也就是说这个读写过程是阻塞的
* 多路复用产生的效果，完全可以由用户态去遍历文件描述符并调用其非阻塞的read函数实现。而多路复用快的原因在于
  * 多路复用快的原因在于操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，变成了一次系统调用 + 内核层遍历这些文件描述符。
  * 好比我们平时写业务代码，把原来 while 循环里调 http 接口进行批量，改成了让对方提供一个批量添加的 http 接口，然后我们一次 rpc 请求就完成了批量添加

### IO多路复用和NIO的区别

* NIO需要在用户程序的循环语句中不停地检查各个socket是否有数据读入，而IO多路复用在用户程序层面则不需要循环语句，虽然IO多路复用也是轮询，但是IO多路复用是交给内核进行各个socket的监控的。
* 由于NIO多次调用read这种系统调用，因此会频繁造成用户态和内核态的转换，而IO多路复用则是先调用select这个系统调用去查询是否有数据就绪的socket，然后有数据就绪，才调用read这个系统调用来读。所以从性能上来说，IO多路复用会比NIO好。
* 在一定程度上来说，IO多路复用算是同步阻塞的一种，因为select会阻塞到有socket数据就绪为止

### IO多路复用到底是不是异步的？

* epoll 这个系统调用，是同步的，也就是必须等待操作系统返回值。
* 而底层用了 epoll 的封装后的框架，可以是异步的，只要你暴露给外部的接口，无需等待你的返回值即可。
* 再多说些，epoll 这个系统调用的底层内核设计里，每个 IO 事件的通知等待，是异步的。但这不影响，epoll 这个系统调用对外部来说，是一个同步的接口。
---

1. 阻塞I/O : 这个 read 函数是操作系统提供的，而且是阻塞的
2. 非阻塞 IO: 操作系统层面提供了非阻塞的 read 函数，这样程序员就可以在一个线程内完成多个文件描述符的读取
  * 但多个文件描述符的读取就需要遍历，当高并发场景越来越多时，用户态遍历的文件描述符也越来越多，相当于在 while 循环里进行了越来越多的系统调用
3. IO 多路复用：操作系统层面提供了selectd等遍历文件描述符的机制
4. 


----
## AIO (Asynchronous I/O)
> Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型

异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作

1. 用户线程通过系统调用，告知 kernel 内核启动某个 IO 操作，用户线程返回。
  1. 当用户线程调用了 read 系统调用，立刻就可以开始去做其它的事，用户线程不阻塞。使用异步通道的概念。其read，write方法的返回类型都是Future对象。
  2. 内核（kernel）就开始了 IO 的第一个阶段：准备数据。
2. Kernel 内核在整个 IO 操作（包括数据准备、数据复制）完成后，通知用户程序，用户执行后续的业务操作
  1. 当 kernel 一直等到数据准备好了，它就会将数据从 kernel 内核缓冲区，拷贝到用户缓冲区（用户内存）。
  2. kernel 会给用户线程发送一个信号（signal），或者回调用户线程注册的回调接口，告诉用户线程 read 操作完成了。
  3. 用户线程读取用户缓冲区的数据，完成后续的业务操作。

<img width="350" alt="Screen Shot 2021-12-18 at 5 36 53 PM" src="https://user-images.githubusercontent.com/27160394/146636542-0d41fd9c-7a7b-44df-a0ba-d4357d43a212.png">




