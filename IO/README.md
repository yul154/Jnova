I/O的底层实现
- I/O的term 
- I/O的分类
---
# I/O 的基本流程

接触最多的就是 磁盘 IO（读写文件） 和 网络 IO（网络请求和响应）

无论是 Socket 的读写还是文件的读写，在 Java 层面的应用开发或者是 linux 系统底层开发，都属于输入 input 和输出 output 的处理，简称为 IO 读写


## 操作系统的基本概念

* 操作系统： 控制和管理整个计算机系统的硬件和软件资源，并合理的组织调度计算机的工作和资源的分配， 以提供用户和其他软件方便的接口和和环境，它是计算机系统中最基本的系统软件。

* 内核：操作系统的核心软件，负责管理系统的进程、内存、设备驱动程序、文件和网络系统等等，为应用程序提供对计算机硬件的安全访问服务



为了避免用户进程直接操作内核，保证内核安全，操作系统将内存寻址空间划分为两部分
* 内核空间（Kernel-space），供内核程序使用 
* 用户空间（User-space）： 供用户进程使用 为了安全，内核空间和用户空间是隔离的，即使用户的程序崩溃了，内核也不受影响

* 抽象数据流(I/O流)的概念：指一组有顺序的、有起点和终点的字节集合


## I/O 过程

> write 把数据从进程缓冲区复制到内核缓冲区，它们不等价于数据在内核缓冲区和磁盘之间的交换

用户程序进行 IO 的读写，基本上会用到系统调用 read&write

> 内核缓冲与进程缓冲区

缓冲区的目的，是为了减少频繁的系统 IO 调用
* 系统内核也有个缓冲区叫做内核缓冲区。
* 每个进程有自己独立的缓冲区，叫做进程缓冲区。


* read 把数据从内核缓冲区复制到进程缓冲区
  * read 系统调用，并不是把数据直接从物理设备，读数据到内存。
  * read 系统调用，是把数据从内核缓冲区复制到进程缓冲区；
* write 把数据从进程缓冲区复制到内核缓冲区
  * write 系统调用，也不是直接把数据，写入到物理设备 
  * write 系统调用，是把数据从进程缓冲区复制到内核缓冲区

<img width="546" alt="Screen Shot 2021-12-18 at 4 20 01 PM" src="https://user-images.githubusercontent.com/27160394/146634657-53194294-ef4e-4706-9109-e026dcc6b2ec.png">

1. 客户端请求，Linux通过网卡，读取客户不断的请求数据，将数据读取到内核缓冲区
2. 获取请求数据，服务器从内核缓冲区读取数据到 Java 进程缓冲区。
3. 服务器端业务处理，Java 服务端在自己的用户空间中，处理客户端的请求。
4. 服务器端返回数据，Java 服务端已构建好的响应，从用户缓冲区写入系统缓冲区。
5. 发送给客户端，Linux 内核通过网络 I/O ，将内核缓冲区中的数据，写入网卡，网卡通过底层的通讯协议，会将数据发送给目标客户端。




从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。

* 为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 用户空间（User space） 和 内核空间（Kernel space ） 。
* 像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。
  * 我们想要进行 IO 操作，一定是要依赖内核空间的能力
  * 用户空间的程序不能直接访问内核空间
* 当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。
    * 因此，用户进程想要执行 IO 操作的话，必须通过 系统调用 来间接访问内核空间
    * 操作系统负责的内核执行具体的 IO 操作
    * 我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的


当应用程序发起 I/O 调用后，会经历两个步骤：
* 内核等待 I/O 设备准备好数据
* 内核将数据从内核空间拷贝到用户空间。

> 那么阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息




# I/O 模型

## 阻塞式 I/O
> 应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回

当进行IO读写时，线程是阻塞的状态。此时会让出cpu控制权，不会占用cpu资源
* 阻塞是指用户空间（调用线程）一直在等待，而且别的事情什么都不做
* 在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞
* 用户空间线程是主动发起 IO 请求的一方，内核空间是被动接受方
* 阻塞状态不会占用CPU，但是会发生线程的切换，线程切换时会有上下文保存转换的过程，需要CPU调度，是一个很昂贵的操作

<img width="369" alt="Screen Shot 2021-12-18 at 5 55 51 PM" src="https://user-images.githubusercontent.com/27160394/146636974-30449026-0e1e-44cb-97ae-22c0406b2be2.png">

### 非阻塞式 I/O

在进行IO操作的时候，如果设备还未准备好（比如socket还没有收到数据），操作会直接返回结果，不会让当前线程进入阻塞状态


<img width="351" alt="Screen Shot 2021-12-18 at 5 56 32 PM" src="https://user-images.githubusercontent.com/27160394/146636990-0e2b6372-ca5f-4be3-9ec9-46fd9ade0056.png">


### I/O 复用

I/O多路复用技术通过把多个I/O的阻塞复用到同一个Select的阻塞上 从而使得系统在单线程的情况下可以同时处理多个客户端请求。
* 以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。
* 与传统的多线程/多进程模型相比，I/O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些线程和进程的运行
* 使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用`recvfrom`把数据从内核复制到进程中



<img width="336" alt="Screen Shot 2021-12-18 at 5 57 18 PM" src="https://user-images.githubusercontent.com/27160394/146637005-1057cb96-6b75-486b-9abb-ed025590df77.png">





### 异步IO：

* 读写IO时仅发出请求，然后立即执行后续代码
* 代码编写复杂，CPU执行效率高
* JDK提供的`java.nio`是异步IO

<img width="370" alt="Screen Shot 2021-12-18 at 5 58 04 PM" src="https://user-images.githubusercontent.com/27160394/146637025-b61c9632-a1d0-4786-8040-8101abe4024a.png">


### 同步IO：

* 读写IO时代码等数据返回后才继续执行后续代码
* 代码编写简单，CPU执行效率低
* JDK提供的`java.io`是同步IO


```
步 I/O 与异步 I/O
同步 I/O: 应用进程在调用 recvfrom 操作时会阻塞。
异步 I/O: 不会阻塞。
```


# Java 中 4 种常见 IO 模型

## BIO (Blocking I/O)
> 属于同步阻塞 IO 模型 

用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间


<img width="305" alt="Screen Shot 2021-12-13 at 3 49 42 PM" src="https://user-images.githubusercontent.com/27160394/145772604-3d19fd8e-1026-47e1-b894-6b7bf861857a.png">


1.  当用户线程调用了read系统调用,内核(kernel)就开始了 IO 的第一个阶段：准备数据.数据在一开始还没有到达（比如，还没有收到一个完整的 Socket 数据包),这个时候 kernel就要等待足够的数据到来。
2. 当 kernel 一直等到数据准备好了，它就会将数据从 kernel 内核缓冲区，拷贝到用户缓冲区（用户内存），然后 kernel 返回结果。
3. 从开始 IO 读的 read 系统调用开始，用户线程就进入阻塞状态。一直到kernel返回结果后，用户线程才解除 block 的状态，重新运行起来。

所以，blocking IO 的特点就是在内核进行 IO 执行的两个阶段，用户线程都被block了。

### 优缺点
* 程序简单，在阻塞等待数据期间，用户线程挂起。用户线程基本不会占用 CPU 资源
* 每个连接配套一条独立的线程，或者说一条线程维护一个连接成功的 IO 流的读写，BIO 模型在高并发场景下是不可用的。


## NIO (Non-blocking/New I/O)
> Java 中的 NIO 可以看作是 I/O 多路复用模型。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型

应用程序会一直发起read调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间

* 在内核缓冲区没有数据的情况下，系统调用会立即返回，返回一个调用失败的信息。
* 在内核缓冲区有数据的情况下，是阻塞的，直到数据从内核缓冲复制到用户进程缓冲。



<img width="375" alt="Screen Shot 2021-12-13 at 3 51 13 PM" src="https://user-images.githubusercontent.com/27160394/145772772-4403a338-3352-4695-9582-098057d5a7d7.png">


1. 在内核数据没有准备好的阶段，用户线程发起 IO 请求时，立即返回。用户线程需要不断地发起 IO 系统调用。
2. 内核数据到达后，用户线程发起系统调用，用户线程阻塞。内核开始复制数据。它就会将数据从 kernel 内核缓冲区，拷贝到用户缓冲区（用户内存），然后 kernel 返回结果。
3. 用户线程才解除 block 的状态，重新运行起来。经过多次的尝试，用户线程终于真正读取到数据，继续执行

所以 NIO 的特点是应用程序的线程需要不断的进行 I/O 系统调用，轮询数据是否已经准备好，如果没有准备好，继续轮询，直到完成系统调用为止。

### NIO 的优缺点：
* 每次发起的 IO 系统调用，在内核的等待数据过程中可以立即返回。用户线程不会阻塞，实时性较好
* 需要不断的重复发起 IO 系统调用，这种不断的轮询，将会不断地询问内核，这将占用大量的 CPU 时间，系统资源利用率较低

## 多路复用 I/O
> Java NIO(New IO)不是 IO 模型中的 NIO 模型，而是IO多路复用模型（IO multiplexing）

多路复用避免同步非阻塞 NIO 模型中轮询等待的问题
* 通过一种新的系统调用，一个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是内核缓冲区可读/可写），内核 kernel 能够通知程序进行相应的 IO 系统调用
* 目前支持 IO 多路复用的系统调用，有 select，epoll 


IO 多路复用模型的基本原理就是 select/epoll 系统调用，单个线程不断的轮询select/epoll 系统调用所负责的成百上千的 socket 连接，当某个或者某些 socket 网络连接有数据到达了，就返回这些可以读写的连接


1. 进行`select/epoll`系统调用，查询可以读的连接。Kernel 会查询所有 select的可查询 socket 列表，当任何一个 socket 中的数据准备好了，select 就会返回。当用户进程调用了select，那么整个线程会被 block（阻塞掉）。
2. 用户线程获得了目标连接后，发起 read 系统调用，用户线程阻塞。内核开始复制数据。它就会将数据从 kernel 内核缓冲区，拷贝到用户缓冲区（用户内存），然后 kernel 返回结果。
3. 用户线程才解除 block 的状态，用户线程终于真正读取到数据，继续执行。


所以多路复用 IO 的特点，IO 多路复用模型，建立在操作系统 kernel 内核能够提供的多路分离系统调用 select/epoll 基础之上的。
* 多路复用 IO 需要用到两个系统调用（system call）
  *  一个 select/epoll 查询调用
  *  一个是 IO 的读取调用。
  


<img width="374" alt="Screen Shot 2021-12-13 at 3 52 14 PM" src="https://user-images.githubusercontent.com/27160394/145772887-3f2b13e2-075d-4174-aa90-8b3914e5d880.png">

IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间->用户空间）还是阻塞的
* 经典的Reactor设计模式，有时也称为`异步阻塞IO`
* 


多路复用 IO 的优点：
* 用 select/epoll 的优势在于，它可以同时处理成千上万个连接。与一条线程维护一个连接相比， I/O 多路复用技术的最大优势是：**系统不必创建线程，也不必维护这些线程，从而大大减小了系统的开销。
* 本质上，select/epoll 系统调用，属于同步 IO，也是阻塞 IO。都需要在读写事件就绪后，自己负责进行读写，也就是说这个读写过程是阻塞的

```
目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用
* select 调用 ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。 
* epoll 调用 ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。

```

Java 中的 NIO ，有一个非常重要的选择器 ( Selector ) 的概念，也可以被称为 多路复用器。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务

<img width="341" alt="Screen Shot 2021-12-13 at 3 55 23 PM" src="https://user-images.githubusercontent.com/27160394/145773306-e07261a3-553d-4e7e-b4e1-9ef835c95047.png">


### 多路复用 IO 的优缺点：
* 用 select/epoll 的优势在于，它可以同时处理成千上万个连接。与一条线程维护一个连接相比，
* 统不必创建线程，也不必维护这些线程，从而大大减小了系统的开销。
* 本质上，select/epoll 系统调用，属于同步 IO，也是阻塞 IO。都需要在读写事件就绪后，自己负责进行读写，也就是说这个读写过程是阻塞的

## AIO (Asynchronous I/O)
> Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型

异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作

1. 用户线程通过系统调用，告知 kernel 内核启动某个 IO 操作，用户线程返回。
  1. 当用户线程调用了 read 系统调用，立刻就可以开始去做其它的事，用户线程不阻塞。
  2. 内核（kernel）就开始了 IO 的第一个阶段：准备数据。
2. Kernel 内核在整个 IO 操作（包括数据准备、数据复制）完成后，通知用户程序，用户执行后续的业务操作
  1. 当 kernel 一直等到数据准备好了，它就会将数据从 kernel 内核缓冲区，拷贝到用户缓冲区（用户内存）。
  2. kernel 会给用户线程发送一个信号（signal），或者回调用户线程注册的回调接口，告诉用户线程 read 操作完成了。
  3. 用户线程读取用户缓冲区的数据，完成后续的业务操作。

<img width="350" alt="Screen Shot 2021-12-18 at 5 36 53 PM" src="https://user-images.githubusercontent.com/27160394/146636542-0d41fd9c-7a7b-44df-a0ba-d4357d43a212.png">




