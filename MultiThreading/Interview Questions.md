> Java有几种实现线程的方法
> 线程的生命周期
> callable 的底层实现

> callable 怎么实现异步的

> 线程间的通信

> 什么是CAS
CAS 指的是现代 CPU 广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。这个指令会对内存中的共享数据做原子的读写操作。

简单介绍一下这个指令的操作过程：
1.CPU 会将内存中将要被更改的数据与期望的值做比较。
2. 这两个值相等时，CPU 才会将内存中的数值替换为新的值。否则便不做操作。
3. 最后，CPU 会将旧的数值返回。最后，CPU 会将旧的数值返回。

CAS 有 3 个操作数，内存值 V，旧的预期值 A，要修改的新值 B。
* 当且仅当预期值 A 和内存值 V 相同时，将内存值 V 修改为 B，
* 否则返回 V。
* 这是一种乐观锁的思路，它相信在它修改之前，没有其它线程去修改它

> volatile 是什么，怎么实现的

如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的

作用
* 保证共享变量的可见性：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。(单例模式双检测用volatile关键字修饰的)
  * 被volatile关键字修饰的变量修改时会立即写入主内存
  * 被volatile关键字修饰的变量修改时，其余线程存放的该变量的副本会被置为无效

* volatile变量的禁止指令重排序
  * 为了提高程序执行的性能，编译器和执行器(处理器)通常会对指令做一些优化(重排序)   

volatile的底层是通过（lock前缀指令）内存屏障来实现的。

* 内存屏障（memory barrier）是一个CPU指令。这条指令可以确保一些特定指令的执行顺序，影响一些数据的可见性(可能是某些指令执行后的结果)。
* 在每一个volatile写操作前面插入一个StoreStore屏障：保证在volatile写之前，其前面的所有普通写操作都已经刷新到主内存中
* 在每一个volatile写操作后面插入一个StoreLoad屏障：避免volatile写与后面可能有的volatile读/写操作重排序
* 在每一个volatile读操作后面插入一个LoadLoad屏障：禁止处理器把上面的volatile读与下面的普通读重排序
* 在每一个volatile读操作后面插入一个LoadStore屏障：禁止处理器把上面的volatile读与下面的普通写重排序

如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存。这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。但这时候其他处理器的缓
* 确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成
* 强制将对缓存的修改操作立即写入主存，利用缓存一致性机制，并且缓存一致性机制会阻止同时修改由两个以上CPU缓存的内存区域数据
* 如果是写操作，它会导致其他CPU中对应的缓存行无效

Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成




> JMM
Java虚拟机规范中定义了一种Java内存模型（Java Memory Model，即JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果
* 主要目标就是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的细节。

JMM中规定所有的变量都存储在主内存（Main Memory）中，每条线程都有自己的工作内存（Work Memory），线程的工作内存中保存了该线程所使用的变量的从主内存中拷贝的副本
* 线程对于变量的读、写都必须在工作内存中进行，而不能直接读、写主内存中的变量
* 本线程的工作内存的变量也无法被其他线程直接访问，必须通过主内存完成

线程的可见性问题
* 对于普通共享变量，线程A将变量修改后，体现在此线程的工作内存。在尚未同步到主内存时，若线程B使用此变量，从主内存中获取到的是修改前的值，便发生了共享变量值的不一致，

> sychronized 是公平锁吗
* 因为Synchronized 获取锁的行为是不公平的，并非是按照申请对象锁的先后时间分配锁的，每次对象锁被释放时，每个线程都有机会获得对象锁，这样有利于提高执行性能，但是也会造成线程饥饿现象
* `RentrantLock`将在创建锁时将锁new为ReentrantLock(true)就可以,公平锁的lock方法在进行cas判断时多了一个hasQueuedPredecessors()方法

> 谈谈对Synchronized关键字，类锁，方法锁，重入锁的理解

> 线程池

> 线程池的状态
> 线程池的关键字和流程
> execute与submit的区别
> 怎么实现多线程计数器，优化
> AtomicInteger 和使用sychronized有什么区别
> 如果用一个线程写，多个线程读，怎么实现
> 自转锁和独占锁的比较

> synchronize的原理

> 谈谈对Synchronized关键字，类锁，方法锁，重入锁的理解

> static synchronized 方法的多线程访问和作用

> 同一个类里面两个synchronized方法，两个线程同时访问的问题

> lock原理

> 死锁的四个必要条件？

> 怎么避免死锁？

> 对象锁和类锁是否会互相影响？

> 如何控制某个方法允许并发访问线程的个数？

> 什么导致线程阻塞？

> 如何保证线程安全？

> 如何实现线程同步？

> 两个进程同时要求写或者读，能不能实现？如何防止进程的同步？

> 谈谈对多线程的理解

> 多线程有什么要注意的问题？

> 谈谈你对并发编程的理解并举例说明

> 谈谈你对多线程同步机制的理解？

> 如何保证多线程读写文件的安全？

> Java的并发、多线程、线程模型
