死锁：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象

##  死锁的四个必要条件

1. 互斥条件：一个资源每次只能被一个进程使用。
2. 占有且等待：进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放
3. 不可强行占有:进程已获得的资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

## 如何避免死锁？

* 合理安排妥当的访问顺序
* 超时放弃

## 如何检测死锁？

1. 首先为每个进程和每个资源指定一个唯一的号码;
2. 然后建立资源分配表和进程等待表，

### 死锁检测的工具
1. Jstack命令: 自带的一种堆栈跟踪工具。jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息
2. JConsole工具: 对运行在Java应用程序的资源消耗和性能进行监控



> 数据库中的死锁避免是否可用刚才说的方法来避免？

1. 以固定的顺序访问表和行。即按顺序申请锁，这样就不会造成互相等待的场面。
2. 大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。
3. 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。
4. 降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。
5. 为表添加合理的索引。如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。

##  如何解决死锁

* 最简单、最常用的方法就是进行系统的重新启动，不过这种方法代价很大，它意味着在这之前所有的进程已经完成的计算工作都将付之东流，包括参与死锁的那些进程，以及未参与死锁的进程
* 撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。
* 进程回退策略，即让参与死锁的进程回退到没有发生死锁前某一点处，并由此点处继续执行，以求再次执行时不再发生死锁
