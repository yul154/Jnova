# 线程
* 程序执行的最小单位
* 进程中的一个执行任务（控制单元


> 什么是进程
* 进程是资源分配的基本单位
* 每个进程都有自己独立的一块内存空间，一个进程可以有多个线程
* 一个在内存中运行的应用程序,应用程序一旦执行，就是一个进程。每个进程都有自己独立的地址空间,每启动一个进程,系统就会为它分配地址空间,建立数据表来维护代码段,堆栈段和数据段

> 进程与线程的区别？
* 进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位
* 同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的
* 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮
* 每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制
* 如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部
* 多进程：操作系统中同时运行的多个程序
* 多线程：在同一个进程中同时运行的多个任务




## 线程状态转换

|Status|Transfer|
|-------|--------|
|`new`| 新创建的一个线程，处于等待状态,`start()`方法标识启动一个线程，并分配资源,让其状态变成`runnable`|
|`runnable`|可运行状态，并不是已经运行，具体的线程调度各操作系统决定. 当线程调用了 start() 方法后，线程则处于就绪 Ready 状态，等待操作系统分配 CPU 时间片，分配后则进入 Running 运行状态,`yield()` 让当前运行线程回到可运行状态，交出时间分片让高优先级的线程先执行，如果持有锁的话是不会释放掉的。
|`waiting`|可被唤醒的等待状态,此状态可以通过 synchronized 获得锁，调用 `wait()` `await` `join()` 方法进入等待状态。最后通过 `notify、notifyall` and `signal,signalAll`唤醒|
|`timeWaiting()`|指定时间内让出CPU资源，此时线程不会被执行，也不会被系统调度，直到等待时间到期后才会被执行,`Thread.sleep(long)`、`Object.wait(long)`、`Thread.join(long)`
|`blocked()`| 当发生锁竞争状态下，没有获得锁的线程会处于挂起状态。比如正在等待另一个线程的 synchronized 块的执行释|
|`terminated`| 从`New` 到`Terminated`是不可逆的。一般是程序流程正常结束或者发生了异常 |

> Difference ammong `Thread.sleep`、`Object.wait`、`Thread.join`,`yield`
* `join()`方法可以使得一个线程在另一个线程结束后再执行,如果线程A调用了线程B的join方法，线程A将被阻塞，等待线程B执行完毕后线程A才会被执行
* `yield`只是让当前对象回到就绪状态，还是有可能马上被再次被调用执行，该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行
* `wait` 让出锁, `sleep` 不让出锁,`yield`也不让出锁
* `yield` 不能被中断，而 `sleep` 则可以接受中断。
* `yield` 直接进入ready的状态，`wait`唤醒后进入ready状态，`sleep`直接进入`running`状态
*  `join()`的底层确实是`wait()`，`wait(`)也确实释放锁，但是释放的是thread的对象锁



> 线程可以阻塞于四种状态
* 当线程执行 Thread.sleep() 时，它一直阻塞到指定的毫秒时间之后，或者阻塞被另一个线程打断；
* 当线程碰到一条 wait() 语句时，它会一直阻塞到接到通知 notify()、被中断或经过了指定毫秒时间为止（若制定了超时值的话）
* 线程阻塞与不同 I/O 的方式有多种。常见的一种方式是 InputStream 的 read() 方法，该方法一直阻塞到从流中读取一个字节的数据为止，它可以无限阻塞，因此不能指定超时时间；
* 线程也可以阻塞等待获取某个对象锁的排他性访问权限（即等待获得 synchronized 语句必须的锁时阻塞）。

## Java实现多线程的方式及三种方式的区别
1. `Runnable --> run()` 实现Runnable接口
2. `Callable --> call()` 实现Callable接口
3. `Thread --> new Thread()` 继承Thread类，重写run方法

Runnable 和 Callable 只能当做一个可以在线程中运行的任务，并不是真正的线程。所以需要 Thread 类来调用

> 实现Runnable/Callable接口相比继承Thread类的优势
* 适合多个线程进行资源共享
* 可以避免java中单继承的限制
* 线程池只能放入Runable或Callable接口实现类，不能直接放入继承Thread的类

> Callable和Runnable的区别
* `Callable`重写的是`call()`方法，`Runnable`重写的方法是`run()`方法
* `call()`方法执行后可以有返回值，`run()`方法没有返回值
* `call()`方法可以抛出异常，`run()`方法不可以
* 运行`Callable`任务可以拿到一个`Future`对象，表示异步计算的结果。通过`Future`对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果

> `Future` and `FutureTask`
* `Future<V>` 接口是用来获取异步计算结果的,Future只是一个接口，我们无法直接创建对象使用的.
*  `FutureTask` which implements both the `Future` and `Runnable` interfaces,由此看出FutureTask它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值.


## Daemon（守护线程）

## 线程阻塞 状态
* 当线程执行 Thread.sleep() 时，它一直阻塞到指定的毫秒时间之后，或者阻塞被另一个线程打断；
* 当线程碰到一条 wait() 语句时，它会一直阻塞到接到通知 notify()、被中断或经过了指定毫秒时间为止（若制定了超时值的话）
* 线程也可以阻塞等待获取某个对象锁的排他性访问权限（即等待获得 synchronized 语句必须的锁时阻塞）。
* 线程阻塞与不同 I/O 的方式有多种。常见的一种方式是 InputStream 的 read() 方法，该方法一直阻塞到从流中读取一个字节的数据为止，它可以无限阻塞，因此不能指定超时时间；

## 中断
通过调用一个线程的`interrupt()`来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线

### interrupt() VS isInterrupted() VS interrupted()
* `interrupt`方法有两个作用：（1）将线程的中断状态设置为true（2）让被阻塞(`sleep(),wait(),join()`)的线程抛出InterruptedException异常（同时中断状态为false）
* `Thread.interrupted()` 检测当前线程是否被中断，并且中断状态会被清除（即重置为false）；由于它是静态方法，因此不能在特定的线程上使用，只能报告调用它的线程的中断状态
* `this.isInterrupted()` 检测调用该方法的线程是否被中断，中断状态不会被清除。

>`stop`
它在终止一个线程时会强制中断线程的执行，不管run方法是否执行完了，并且还会释放这个线程所持有的所有的锁对象，导致数据不一致

### Executor 的中断操作
* 调用`Executor`的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的`interrupt()`方法。
* 如果只想中断`Executor`中的一个线程，可以通过使用 submit()方法来提交一个线程，它会返回一个 Future<?> 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。

> `stop`
它在终止一个线程时会强制中断线程的执行，不管run方法是否执行完了，并且还会释放这个线程所持有的所有的锁对象，导致数据不一致
---
# 线程安全
* 一个方法或者一个实例可以在多线程环境中使用而不会出现问题
* 当多个线程访问某个方法时，不管你通过怎样的调用方式或者说这些线程如何交替的执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为
* 当多个线程访问某个类时，这个类始终都能表现出正确的行为
* 线程安全就是说多线程访问同一代码，不会产生不确定的结果

线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据

## JAVA确保线程安全的方法
1. Synchronized：synchronized关键字就是用于代码,JVM的内置锁，底层原理是通过monitor对象来完成的对实现方法与代码块的同步
2. 使用Lock接口下的实现类，常用的实现类就是ReentrantLock类
3. 使用线程本地存储ThreadLocal：当多个线程操作同一个变量且互不干扰的场景下,可以使用ThreadLocal来解决.它会在每个线程中对该变量创建一个副本,且在线程内部任何地方都可以使用，线程之间互不影响


> Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问
* 第一个是 JVM 实现的 synchronized，: 它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。
* 另一个是 JDK 实现的 ReentrantLock : 重入锁（ReentrantLock）是一种递归无阻塞的同步机制
  1. 等待可中断:当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。
  2. 可实现公平锁: 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。 synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。
   3. 锁绑定多个条件 : 一个 ReentrantLock 对象可以同时绑定多个 Condition 对象。


### `synchronized`
> 一个表现为原生语法层面的互斥锁，它是一种悲观锁

####  `synchronized` 底层原理
> synchronized的底层原理是通过monitor对象来完成的, `synchronized`关键字底层实现主要是通过`monitorenter`与`monitorexit`计数 

synchronized在JVM里的实现就是基于进入和退出monitor来实现的

对象在内存中分为三块区域
* 对象头
  * Mark Word，用于存储对象自身运行时的数据，如哈希码(Hash Code)，GC分代年龄，锁状态标志，偏向线程ID、偏向时间戳等信息，它会根据对象的状态复用自己的存储空间。它是实现轻量级锁和偏向锁的关键
  * 类型指针，对象会指向它的类的元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例

* 存放类的属性数据信息，包括父类的属性信息。
* 由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐


使用同步代码块被标志的地方就是刚刚提到的对象头，它会关联一个monitor对象
* `monitorenter`，如果当前monitor的进入数为0时，线程就会进入monitor，并且把进入数+1，那么该线程就是monitor的拥有者(owner)。
* 如果该线程已经是monitor的拥有者，又重新进入，就会把进入数再次+1。也就是可重入的。
* `monitorexit`，执行monitorexit的线程必须是monitor的拥有者，指令执行后，monitor的进入数减1，如果减1后进入数为0，则该线程会退出monitor。其他被阻塞的线程就可以尝试去获取monitor的所有权

同步方法原理
* `ACC_SYNCHRONIZED`，作用就是一旦执行到这个方法时，就会先判断是否有标志位，如果有这个标志位，就会先尝试获取monitor，获取成功才能执行方法，方法执行完成后再释放monitor。在方法执行期间，其他线程都无法获取同一个monitor



>`synchronized`锁升级
synchronized 可以认为是重量级锁。但是，JVM 为了减少不必要的消耗，为 synchronized 提供了四种状态：无锁状态、偏向锁、轻量级锁和重量级锁

* 无锁 : 不锁定资源，多个线程只有一个能修改资源成功，其他线程会重试
* 偏向锁: 大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，去掉同步操作,相当于无锁
* 轻量级锁: 多个资源抢夺同步资源，没有获得锁的线程使用CAS自转等锁的释放
* 重量级锁: 多个线程争夺同步资源的时候，当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态


1. 在锁对象的对象头里面有一个`threadid`字段，在第一次访问的时候`threadid`为空，jvm 让其持有偏向锁,并将 threadid 设置为其线程 id
2. 再次进入的时候会先判断`threadid`是否与其线程`id`一致，如果一致则可以直接使用此对象.不一致，则升级偏向锁为轻量级锁, 通过自旋循环一定次数来获取锁
3. 执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁

```
1. Sychronzed 锁的object的对象头markword 默认值是001，也就是无锁状态
2. 线程1执行同步代码块，在第一次访问的时候`threadid`为空，jvm 让其持有偏向锁,并将 threadid 设置为其线程 id
3. 线程2访问代码块尝试获取锁，如果线程1还持有锁，JVM把锁升级成轻量级锁
4. 线程2进行CAS自转，尝试获取轻量级锁
5. 等到线程2自转到一定次数后，JVM膨胀成重量级锁，自旋次数可以通过JVM参数设置
```

* 无锁 : 指没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。
* 偏向锁(无锁):大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后（线程的id会记录在对象的Mark Word中），消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。
* 轻量级锁(CAS)：就是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁；轻量级锁的意图是在没有多线程竞争的情况下，通过CAS操作尝试将MarkWord更新为指向LockRecord的指针，减少了使用重量级锁的系统互斥量产生的性能消耗。
* 重量级锁：指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态, 虚拟机使用CAS操作尝试将MarkWord更新为指向LockRecord的指针，如果更新成功表示线程就拥有该对象的锁；如果失败，会检查MarkWord是否指向当前线程的栈帧，如果是，表示当前线程已经拥有这个锁；如果不是，说明这个锁被其他线程抢占，此时膨胀为重量级锁


* 偏向锁通过对比 Mark Word 解决加锁问题，避免执行CAS操作。
* 轻量级锁是通过用 CAS 操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。
* 重量级锁是将除了拥有锁的线程以外的线程都阻塞。


CAS:判断内存某个位置的值是否为预期值，如果是则更改为新的值
* 当我们需要对内存中的数据进行修改操作时，为了避免多线程并发修改的情况，我们在对他进行修改操作前，先读取他原来的值E，然后进行计算得出新的的值V，
* 在修改前去比较当前内存中的值N是否和我之前读到的E相同，如果相同，认为其他线程没有修改过内存中的值，如果不同，说明被其他线程修改了，
* 这时，要继续循环去获取最新的值E，再进行计算和比较，直到我们预期的值和当前内存中的值相等时，再对数据执行修改操作。

### 了解锁吗，有几种上锁的方式

1. 对象锁（同步块）——锁某一个对象
2. 类锁
3. 实例锁——锁的是当前实例


### synchronized与lock的区别，使用场景。看过synchronized的源码没？

ReentrantLock 是 （J.U.C）包中的锁，相比于 synchronized，它多了以下高级功能：
* 等待可中断:当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。
* 可实现公平锁: 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。
* 锁绑定多个条件 : 一个 ReentrantLock 对象可以同时绑定多个 Condition 对象。


1.区别：
* Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；
* synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；
* Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；`lockInterruptibly()`的用法体现了Lock的可中断性
* 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。
* Lock可以提高多个线程进行读操作的效率。
* 总结：ReentrantLock相比synchronized，增加了一些高级的功能。但也有一定缺陷。

> 使用场景
真正的高级用户喜欢选择能够找到的最简单工具，直到他们认为简单的工具不适用为止。

在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而 当竞争资源非常激烈时（即有大量线程同时竞争），此时ReentrantLock的性能要远远优于synchronized。在确实需要一些 synchronized 所没有的特性的时候，比如时间等候、可中断锁等候、无块结构锁、多个条件变量或者轮询锁。 ReentrantLock 还具有可伸缩性的好处，应当在高度争用的情况下使用它，但是请记


### volatile 与 synchronized 的区别
* 执行控制的目的是控制代码执行（顺序）及是否可以并发执行。
* 内存可见控制的是线程执行结果在内存中对其它线程的可见性


### 什么是线程安全
当多个线程访问同一个对象时，
* 如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，
* 调用这个对象的行为都可以获取正确的结果，那这个对象是线程安全的

如何保证线程安全？（更加详细的请转向第一部分 11. 线程安全）

* 对变量使用 volitate
* 对程序段进行加锁 (synchronized , lock)

### 什么是乐观锁和悲观锁

* 为什么需要锁（并发控制）
  * 在多用户环境中，在同一时间可能会有多个用户更新相同的记录，这会产生冲突。这就是著名的并发性问题。
  * 典型的冲突有：
      1. 丢失更新：一个事务的更新覆盖了其它事务的更新结果，就是所谓的更新丢失。例如：用户 A 把值从 6 改为 2，用户 B 把值从 2 改为 6，则用户 A 丢失了他的更新。
      2. 脏读：当一个事务读取其它完成一半事务的记录时，就会发生脏读取。例如：用户 A,B 看到的值都是6，用户 B 把值改为 2，用户 A 读到的值仍为 6。
* 为了解决这些并发带来的问题。 我们需要引入并发控制机制。
  * 并发控制机制
    * 悲观锁：假定会发生并发冲突，独占锁，屏蔽一切可能违反数据完整性的操作。
    * 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁不能解决脏读的问题。

### 线程之间的协作  线程AB，让A在B前执行，有几种方法
* `join()`: 会将当前线程挂起，而不是忙等待，直到目标线程结束。
* `wait() notify() notifyAll()`(Object): 调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify()（随机叫醒一个） 或者 notifyAll() （叫醒所有 wait 线程，争夺时间片的线程只有一个）来唤醒挂起的线程。
* `await() signal() signalAll()`(java.util.concurrent):提供了 Condition 类来实现线程之间的协调

### 死锁 什么是死锁，怎么解决死锁，怎么避免死锁
如果一组进程中的每个进程都在等待一个事件，而这个事件只能由该组中的另一个进程触发，这种情况会导致死锁。
使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。

资源有序分配法呢？
* 线程 A 和 线程 B 获取资源的顺序要一样，当线程 A 是先尝试获取资源 A，然后尝试获取资源 B 的时候，线程 B 同样也是先尝试获取资源 A，然后尝试获取资源 B。也就是说，线程 A 和 线程 B 总是以相同的顺序申请自己想要的资源。

### sleep和wait有什么区别

* wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；
* wait() 会释放锁，sleep() 不会
* sleep() 方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）。
* wait() 是 Object 类的方法，调用对象的 wait() 方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的 notify() 方法（或 notifyAll() 方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。

## J.U.C

## 线程池
* 线程是稀缺资源，如果被无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，合理的使用线程池对线程进行统一分配、调优和监控，有以下好处：
1. 降低资源消耗；
2. 提高响应速度；
3. 提高线程的可管理性。


### 线程池原理
* 线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；
* 如果当前线程数为 corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果阻塞队列满了，那就创建新的线程执行当前任务；直到线程池中的线程数达到 maxPoolSize，这时再有任务来，只能执行 reject() 处理该任务。

### 线程池的核心参数,自己创建的话，什么情况下使用什么参数？
* corePoolSize 核心线程数
* maximumPoolSize 最大线程数
* keepAliveTime 空闲线程存活时间
* unit 对应keepAliveTime的计量单位
* workQueue 工作队列
* threadFactory 线程工厂，用于创建线程可以指定线程名、是否为daemon线程等
* handler 拒绝策略

### 线程池分类 你用过线程池吗？讲一讲线程池的构造？讲讲自带的几个线程池，什么场景下使用哪个 线程池你自己实现，怎么实现,了解线程池吗，有几种实现方法
* newFixedThreadPool() 说明：初始化一个指定线程数的线程池，其中 corePoolSize == maxiPoolSize，使用 LinkedBlockingQuene 作为阻塞队列 特点：即使当线程池没有可执行任务时，也不会释放线程。(用于负载比较重的服务器，为了资源的合理利用，需要限制当前线程数量)
* newCachedThreadPool() 说明：初始化一个可以缓存线程的线程池，默认缓存60s，线程池的线程数可达到 Integer.MAX_VALUE，即 2147483647，内部使用 SynchronousQueue 作为阻塞队列； 特点：在没有任务执行时，当线程的空闲时间超过 keepAliveTime，会自动释放线程资源；当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销； 因此，使用时要注意控制并发的任务数，防止因创建大量的线程导致而降低性能。(用于并发执行大量短期的小任务，或者是负载较轻的服务器；)
* newSingleThreadExecutor() 说明：初始化只有一个线程的线程池，内部使用 LinkedBlockingQueue 作为阻塞队列。 特点：如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行 ( 用于串行执行任务的场景，每个任务必须按顺序执行，不需要并发执行)
* newScheduledThreadPool() 特点：初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据。




###  线程池常用方法
* execute与submit的区别， 接收的参数不一样， submit有返回值，而execute没有

### 关于 workQueue 参数，有四种队列可供选择：
* ArrayBlockingQueue：基于数组结构的有界阻塞队列，按 FIFO 排序任务；
* LinkedBlockingQuene：基于链表结构的阻塞队列，按 FIFO 排序任务；
* SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 ArrayBlockingQuene；
* PriorityBlockingQuene：具有优先级的无界阻塞队列

### 线程池的状态
* RUNNING：-1 << COUNT_BITS，即高 3 位为 111，该状态的线程池会接收新任务，并处理阻塞队列中的任务；
* SHUTDOWN： 0 << COUNT_BITS，即高 3 位为 000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；
* STOP ： 1 << COUNT_BITS，即高 3 位为 001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；
* TIDYING ： 2 << COUNT_BITS，即高 3 位为 010，该状态表示线程池对线程进行整理优化；
* TERMINATED： 3 << COUNT_BITS，即高 3 位为 011，该状态表示线程池停止工作；



1. 多线程编程，你的项目中有哪些运用到了
### 线程同步的方式有哪些？
1. synchronized关键字修饰的方法
2. synchronized关键字修饰的语句块
3. 使用特殊域变量(volatile)实现线程同步
4. 使用重入锁实现线程同步
5. 使用localThread 实现线程同步: 每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响
6. 使用阻塞队列实现线程同步


### ThreadLocal原理及使用，如何防止内存泄漏
ThreadLocal，即线程局部变量，用来为每一个使用它的线程维护一个独立的变量副本,在多线程环境下，防止自己的变量被其它线程篡改
* 这种变量只在线程的生命周期内有效
* 它以空间换取时间的方式保证变量的线程安全

>原理
`ThreadLocalMap`是`ThreadLocal`的静态内部类，也是实际保存变量的类。
`Entry`是`ThreadLocalMap`的静态内部类。`ThreadLocalMap`持有`一个Entry`数组
* 每个Thread线程内部都有一个ThreadLocalMap
* ThreadLocalMap拥有一个Entry数组,没有实现Map接口。是用Entry类型的数组来实现的，没有hashmap中的链表结构
* 每个Entry都有k--v,ThreadLocalMap里面存储ThreadLocal（key）和线程的变量副本（value）

当调用ThreadLocal的get()方法的时候，
* 会先找到当前线程的ThreadLocalMap，然后再找到对应的值。
* set()方法也是一样。所以对于不同的线程，每次获取副本值时，
* 首先会通过getMap方法来获取当前线程中的ThreadLocalMap对象。如果获取到的ThreadLocalMap初始值为null，那么就要对其进行初始化，调用createMap方法
* 只能在当前线程的ThreadLocalMap中去找，别的线程并不能获取到当前线程的副本值，这样就形成了副本的隔离

每个ThreadLocal对象都有一个hash值 threadLocalHashCode，每初始化一个ThreadLocal对象，hash值就增加一个固定的大小 0x61c88647。
*  在插入过程中，根据ThreadLocal对象的hash值，定位到table中的位置i，过程如下：
1、如果当前位置是空的，那么正好，就初始化一个Entry对象放在位置i上；
2、不巧，位置i已经有Entry对象了，如果这个Entry对象的key正好是即将设置的key，那么重新设置Entry中的value；
3、很不巧，位置i的Entry对象，和即将设置的key没关系，那么只能找下一个空位置；

> 内存泄露
* ThreadLoalMap的Entry是继承WeakReference的（弱引用，生命周期只能存活到下次GC前），只有Key是弱引用类型的，Value并非弱引用。
* 发生GC时，key被回收，这样我们就无法访问key为null的value元素，
* 如果value本身是较大的对象，那么线程一直不结束的话，value就一直无法得到回收。
* 特别是在我们使用线程池时，线程是复用的，不会杀死线程，这样ThreadLocal弱引用被回收时，value不会被回收。

每次使用完ThreadLocal，都调用它的remove()方法，清除数据,将Entry节点和Map的引用关系移除，这样整个Entry对象在GC Roots分析后就变成不可达了，下次GC的时候就可以被回收

> 为什么用弱引用
假如使用强引用，当ThreadLocal不再使用需要回收时，发现某个线程中ThreadLocalMap存在该ThreadLocal的强引用，无法回收，造成内存泄漏
因此，使用弱引用可以防止长期存在的线程（通常使用了线程池）导致ThreadLocal无法回收造成内存泄漏。

> ThreadLocal变量为什么用static修饰
为了避免重复创建TSO
* 一个ThreadLocal实例对应当前线程中的一个TSO实例。因此，如果把ThreadLocal声明为某个类的实例变量（而不是静态变量），那么每创建一个该类的实例就会导致一个新的TSO实例被创建
* 显然，这些被创建的TSO实例是同一个类的实例
* 同一个线程可能会访问到同一个TSO（指类）的不同实例，这即便不会导致错误，也会导致浪费
19. 分布式锁
