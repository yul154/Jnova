
## 线程状态转换

## Java实现多线程的方式及三种方式的区别

## Daemon（守护线程）

## 线程阻塞 状态
* 当线程执行 Thread.sleep() 时，它一直阻塞到指定的毫秒时间之后，或者阻塞被另一个线程打断；
* 当线程碰到一条 wait() 语句时，它会一直阻塞到接到通知 notify()、被中断或经过了指定毫秒时间为止（若制定了超时值的话）
* 线程也可以阻塞等待获取某个对象锁的排他性访问权限（即等待获得 synchronized 语句必须的锁时阻塞）。
* 线程阻塞与不同 I/O 的方式有多种。常见的一种方式是 InputStream 的 read() 方法，该方法一直阻塞到从流中读取一个字节的数据为止，它可以无限阻塞，因此不能指定超时时间；

## 中断

通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线

### interrupt() VS isInterrupted() VS interrupted()
* `interrupt`方法有两个作用：（1）将线程的中断状态设置为true（2）让被阻塞的线程抛出InterruptedException异常（同时中断状态为false）
* `Thread.interrupted()` 检测当前线程是否被中断，并且中断状态会被清除（即重置为false）；由于它是静态方法，因此不能在特定的线程上使用，只能报告调用它的线程的中断状态
* `this.isInterrupted()` 检测调用该方法的线程是否被中断，中断状态不会被清除。

### Executor 的中断操作
* 调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。
* 如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future<?> 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。

## Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问
* 第一个是 JVM 实现的 synchronized，: 它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。
* 另一个是 JDK 实现的 ReentrantLock : 重入锁（ReentrantLock）是一种递归无阻塞的同步机制
  1. 等待可中断:当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。
  2. 可实现公平锁: 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。 synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。
   3. 锁绑定多个条件 : 一个 ReentrantLock 对象可以同时绑定多个 Condition 对象。

### 了解锁吗，有几种上锁的方式

1. 对象锁（同步块）——锁某一个对象
2. 类锁
3. 实例锁——锁的是当前实例


### synchronized与lock的区别，使用场景。看过synchronized的源码没？

### volatile 与 synchronized 的区别

### 什么是线程安全
当多个线程访问同一个对象时，
* 如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，
* 调用这个对象的行为都可以获取正确的结果，那这个对象是线程安全的

如何保证线程安全？（更加详细的请转向第一部分 11. 线程安全）

* 对变量使用 volitate
* 对程序段进行加锁 (synchronized , lock)

### 什么是乐观锁和悲观锁

* 为什么需要锁（并发控制）
  * 在多用户环境中，在同一时间可能会有多个用户更新相同的记录，这会产生冲突。这就是著名的并发性问题。
  * 典型的冲突有：
      1. 丢失更新：一个事务的更新覆盖了其它事务的更新结果，就是所谓的更新丢失。例如：用户 A 把值从 6 改为 2，用户 B 把值从 2 改为 6，则用户 A 丢失了他的更新。
      2. 脏读：当一个事务读取其它完成一半事务的记录时，就会发生脏读取。例如：用户 A,B 看到的值都是6，用户 B 把值改为 2，用户 A 读到的值仍为 6。
* 为了解决这些并发带来的问题。 我们需要引入并发控制机制。
  * 并发控制机制
    * 悲观锁：假定会发生并发冲突，独占锁，屏蔽一切可能违反数据完整性的操作。
    * 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁不能解决脏读的问题。

### 线程之间的协作  线程AB，让A在B前执行，有几种方法
* `join()`: 会将当前线程挂起，而不是忙等待，直到目标线程结束。
* `wait() notify() notifyAll()`(Object): 调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify()（随机叫醒一个） 或者 notifyAll() （叫醒所有 wait 线程，争夺时间片的线程只有一个）来唤醒挂起的线程。
* `await() signal() signalAll()`(java.util.concurrent):提供了 Condition 类来实现线程之间的协调

### 死锁 什么是死锁，怎么解决死锁，怎么避免死锁
如果一组进程中的每个进程都在等待一个事件，而这个事件只能由该组中的另一个进程触发，这种情况会导致死锁。
使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。

资源有序分配法呢？
* 线程 A 和 线程 B 获取资源的顺序要一样，当线程 A 是先尝试获取资源 A，然后尝试获取资源 B 的时候，线程 B 同样也是先尝试获取资源 A，然后尝试获取资源 B。也就是说，线程 A 和 线程 B 总是以相同的顺序申请自己想要的资源。

### sleep和wait有什么区别

* wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；
* wait() 会释放锁，sleep() 不会
* sleep() 方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）。
* wait() 是 Object 类的方法，调用对象的 wait() 方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的 notify() 方法（或 notifyAll() 方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。

## J.U.C

## 线程池
* 线程是稀缺资源，如果被无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，合理的使用线程池对线程进行统一分配、调优和监控，有以下好处：
1. 降低资源消耗；
2. 提高响应速度；
3. 提高线程的可管理性。


### 线程池原理
* 线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；
* 如果当前线程数为 corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果阻塞队列满了，那就创建新的线程执行当前任务；直到线程池中的线程数达到 maxPoolSize，这时再有任务来，只能执行 reject() 处理该任务。

### 线程池的核心参数,自己创建的话，什么情况下使用什么参数？
* corePoolSize 核心线程数
* maximumPoolSize 最大线程数
* keepAliveTime 空闲线程存活时间
* unit 对应keepAliveTime的计量单位
* workQueue 工作队列
* threadFactory 线程工厂，用于创建线程可以指定线程名、是否为daemon线程等
* handler 拒绝策略

### 线程池分类 你用过线程池吗？讲一讲线程池的构造？讲讲自带的几个线程池，什么场景下使用哪个 线程池你自己实现，怎么实现,了解线程池吗，有几种实现方法
* newFixedThreadPool() 说明：初始化一个指定线程数的线程池，其中 corePoolSize == maxiPoolSize，使用 LinkedBlockingQuene 作为阻塞队列 特点：即使当线程池没有可执行任务时，也不会释放线程。(用于负载比较重的服务器，为了资源的合理利用，需要限制当前线程数量)
* newCachedThreadPool() 说明：初始化一个可以缓存线程的线程池，默认缓存60s，线程池的线程数可达到 Integer.MAX_VALUE，即 2147483647，内部使用 SynchronousQueue 作为阻塞队列； 特点：在没有任务执行时，当线程的空闲时间超过 keepAliveTime，会自动释放线程资源；当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销； 因此，使用时要注意控制并发的任务数，防止因创建大量的线程导致而降低性能。(用于并发执行大量短期的小任务，或者是负载较轻的服务器；)
* newSingleThreadExecutor() 说明：初始化只有一个线程的线程池，内部使用 LinkedBlockingQueue 作为阻塞队列。 特点：如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行 ( 用于串行执行任务的场景，每个任务必须按顺序执行，不需要并发执行)
* newScheduledThreadPool() 特点：初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据。




###  线程池常用方法
* execute与submit的区别， 接收的参数不一样， submit有返回值，而execute没有

### 关于 workQueue 参数，有四种队列可供选择：
* ArrayBlockingQueue：基于数组结构的有界阻塞队列，按 FIFO 排序任务；
* LinkedBlockingQuene：基于链表结构的阻塞队列，按 FIFO 排序任务；
* SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 ArrayBlockingQuene；
* PriorityBlockingQuene：具有优先级的无界阻塞队列

### 线程池的状态
* RUNNING：-1 << COUNT_BITS，即高 3 位为 111，该状态的线程池会接收新任务，并处理阻塞队列中的任务；
* SHUTDOWN： 0 << COUNT_BITS，即高 3 位为 000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；
* STOP ： 1 << COUNT_BITS，即高 3 位为 001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；
* TIDYING ： 2 << COUNT_BITS，即高 3 位为 010，该状态表示线程池对线程进行整理优化；
* TERMINATED： 3 << COUNT_BITS，即高 3 位为 011，该状态表示线程池停止工作；



1. 多线程编程，你的项目中有哪些运用到了
### 线程同步的方式有哪些？
1. synchronized关键字修饰的方法
2. synchronized关键字修饰的语句块
3. 使用特殊域变量(volatile)实现线程同步
4. 使用重入锁实现线程同步
5. 使用localThread 实现线程同步: 每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响
6. 使用阻塞队列实现线程同步

### ThreadLocal原理及使用，如何防止内存泄漏





19. 分布式锁
