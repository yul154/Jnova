# volatile 是什么，怎么实现的

如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的

作用
* 保证共享变量的可见性：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。(单例模式双检测用volatile关键字修饰的)
  * 被volatile关键字修饰的变量修改时会立即写入主内存
  * 被volatile关键字修饰的变量修改时，其余线程存放的该变量的副本会被置为无效

* volatile变量的禁止指令重排序
  * 为了提高程序执行的性能，编译器和执行器(处理器)通常会对指令做一些优化(重排序)   


## volatile 的实现原理
> volatile 变量的内存可见性是基于内存屏障(Memory Barrier)实现:

volatile的底层是通过（lock前缀指令）内存屏障来实现的。

* 内存屏障（memory barrier）是一个CPU指令。这条指令可以确保一些特定指令的执行顺序，影响一些数据的可见性(可能是某些指令执行后的结果)。
* 在每一个volatile写操作前面插入一个StoreStore屏障：保证在volatile写之前，其前面的所有普通写操作都已经刷新到主内存中
* 在每一个volatile写操作后面插入一个StoreLoad屏障：避免volatile写与后面可能有的volatile读/写操作重排序
* 在每一个volatile读操作后面插入一个LoadLoad屏障：禁止处理器把上面的volatile读与下面的普通读重排序
* 在每一个volatile读操作后面插入一个LoadStore屏障：禁止处理器把上面的volatile读与下面的普通写重排序

lock 前缀的指令在多核处理器下会引发两件事情:
* 将当前处理器缓存行的数据写回到系统内存。
* 写回内存的操作会使在其他 CPU 里缓存了该内存地址的额数据无效。

如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存。
* 这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据
* 利用缓存一致性机制，并且缓存一致性机制会阻止同时修改由两个以上CPU缓存的内存区域数据,当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态
* 当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。
* 确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成


Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成

> volatile 的 happens-before 关系

happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。

> volatile 线程安全吗？

volatile不能保证完全的原子性，只能保证单次的读/写操作具有原子性

> i++为什么不能保证原子性?

1. 读取i的值。
2. 对i加1。
3. 将i的值写回内存
*  我们可以通过`AtomicInteger`或者`Synchronized`来保证+1操作的原子性

* 线程A首先得到了i的初始值100，但是还没来得及修改，就阻塞了，
* 这时线程B开始了，它也得到了i的值，由于i的值未被修改，即使是被volatile修饰，主存的变量还没变化，那么线程B得到的值也是100，之后对其进行加1操作，得到101后，将新值写入到缓存中，再刷入主存中。根据可见性的原则，这个主存的值可以被其他线程可见。
*  问题来了，线程A已经读取到了i的值为100，也就是说读取的这个原子操作已经结束了，所以这个可见性来的有点晚，线程A阻塞结束后，继续将100这个值加1，得到101，再将值写到缓存最后刷入主存，所以即便是volatile具有可见性，也不能保证对它修饰的变量具有原子性。
