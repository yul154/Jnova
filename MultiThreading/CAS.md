# 乐观锁

乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。

乐观锁的实现方式主要有两种：CAS机制和版本号机制

## CAS
> 阻塞/唤醒这些操作，是非常消耗时间的

CAS操作包括了3个操作数：

1. 需要读写的内存位置(V)
2. 进行比较的预期值(A)
3. 拟写入的新值(B)


```
public static void increment() {
    do{
        int k = i;
        int j = k + 1;
    }while (compareAndSet(i, k, j))
}
```

1.线程从内存中读取 i 的值，假如此时 i 的值为 0，我们把这个值称为 k 吧，即此时 k = 0。
2. 令 j = k + 1。
3. 用 k 的值与内存中i的值相比，如果相等，这意味着没有其他线程修改过 i 的值，我们就把 j（此时为1） 的值写入内存；
4. 如果不相等（意味着i的值被其他线程修改过），我们就不把j的值写入内存，而是重新跳回步骤 1，继续这三个操作。


> CAS包含了Compare和Swap两个操作，它又如何保证原子性呢
CAS是由CPU支持的原子操作，其原子性是在硬件层面进行保证的


AtomicInteger。AtomicInteger是java.util.concurrent.atomic包提供的原子类，利用CPU提供的CAS操作来保证原子性；除了AtomicInteger外，还有AtomicBoolean、AtomicLong、AtomicReference等众多原子类


### 能否保证 increment 是线程安全的呢
> 采用 CAS 这种机制的写法也是线程安全的，通过这种方式，可以说是不存在锁的竞争，也不存在阻塞等事情的发生，可以让程序执行的更好

这个`compareAndSet`操作，他其实只对应操作系统的一条硬件操作指令，尽管看似有很多操作在里面，但操作系统能够保证他是原子执行的

### CAS的底层实现

* CAS的实现就调用了`UnSafe`方法中的`compareAndSwap***`的系列native方法。
* Unsafe是用来帮助Java访问操作系统底层资源的类
* 这些nativie方法其实在底层都是通过CPU指令实现的，因此CAS操作本身是很快的，这也是为什么CAS自旋的方式想必加锁能够提高性能的原因


### CAS的实现

在 Java 中，也是提供了这种 CAS 的原子类，例如：
```
AtomicBoolean
AtomicInteger
AtomicLong
AtomicReference
```

### ABA 问题

比较有效的方案是引入版本号
* 内存中的值每发生一次变化，版本号都+1；
* 在进行CAS操作时，不仅比较内存中的值，也会比较版本号，
* 只有当二者都没有变化时，CAS才能执行成功。
* Java中的AtomicStampedReference类便是使用版本号来解决ABA问题的。
    * 该工具内部维护了一个内部类，在原有基础上维护了一个对象，及一个int类型的值（可以理解为版本号），
    * 在每次进行对比修改时，都会先判断要修改的值，和内存中的值是否相同，以及版本号是否相同，
    * 如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值


### Java8 对 CAS 的优化。
> 由于线程太密集了，太多人想要修改 i 的值了，进而大部分人都会修改不成功，白白着在那里循环消耗资源

尝试使用分段CAS以及自动分段迁移的方式

Java 8推出了一个新的类，LongAdder
* Java 8推出了一个新的类，LongAdder
```
transient volatile long base;
transient volatile Cell[] cells; //初始值为 null，只有在对 base 执行 CAS 更新失败时（说明竞争激烈）才会用到 cells 这个数组
```


```
如果有 100 个线程要对 i 进行自增操作的话， 这个时候，冲突就会大大增加，
系统就会把这些线程分配到不同的 cell 数组元素去，
假如 cell[10] 有 10 个元素吧，且元素的初始化值为 0，
那么系统就会把 100 个线程分成 10 组，每一组对 cell 数组其中的一个元素做自增操作，
这样到最后，cell 数组 10 个元素的值都为 10，系统在把这 10 个元素的值进行汇总，进而得到 100，二这，就等价于 100 个线程对 i 进行了 100 次自增操作
```
---
##  版本号机制

版本号机制的基本思路是在数据中增加一个字段version，表示该数据的版本号，
* 每当数据被修改，版本号加1。
* 当某个线程查询数据时，将该数据的版本号一起查出来；
* 当该线程更新数据时，判断当前版本号与之前读取的版本号是否一致，如果一致才进行操作

---
## 优缺点和适用场景

* CAS只能保证单个变量操作的原子性，当涉及到多个变量时，CAS是无能为力的，而synchronized则可以通过对整个代码块加锁来处理。
* 版本号机制，如果query的时候是针对表1，而update的时候是针对表2，也很难通过简单的版本号来实现乐观锁
* 当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。
* 当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源。
* CAS一般适用于读多写少的场景，因为这种情况线程的冲突不会太多，也只有线程冲突不严重的情况下，CAS的线程循环次数才能有效的降低，性能也能更高

### CAS有哪些缺点？
1. ABA问题
2. 高竞争下的开销问题:
    * CAS一直失败，会一直重试，CPU开销较大针对这个问题的一个思路是引入退出机制，如重试次数超过一定阈值后失败退出。
    * 当然，更重要的是避免在高竞争环境下使用乐观锁
3. 只能保证一个共享变量的原子操作
---
## 乐观锁加锁吗？
1. 乐观锁本身是不加锁的，只是在更新时判断一下数据是否被其他线程更新了；AtomicInteger便是一个例子。
2. 有时乐观锁可能与加锁操作合作，例如，在前述updateCoins()的例子中，MySQL在执行update时会加排它锁。但这只是乐观锁与加锁操作合作的例子，不能改变“乐观锁本身不加锁”这一事实。
