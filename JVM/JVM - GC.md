
JVM 基础 
- Java 垃圾回收基础 判断一个对象是否可被回收 
  - 引用计数算法 
  - 可达性分析算法 
  - 方法区的回收 
  - finalize() 
- 引用类型 
  - 强引用 
  - 软引用 
  - 弱引用 
  - 虚引用 
- 垃圾回收算法 
  - 标记 - 清除 
  - 标记 - 整理 
  - 复制 
  - 分代收集 
- 垃圾收集器 
   - Serial 收集器 
   - ParNew 收集器 
   - Parallel Scavenge 收集器 
   - Serial Old 收集器 
   - Parallel Old 收集器 
   - CMS 收集器 
   - G1 收集器 
- 内存分配与回收策略
  - Minor GC 和 Full GC 
  - 内存分配策略 
    - 对象优先在 Eden 分配 
    - 大对象直接进入老年代 
    - 长期存活的对象进入老年代 
    - 动态对象年龄判定 
    - 空间分配担保 
  - Full GC 的触发条件 
   - 调用 System.gc() 
   - 老年代空间不足 
   - 空间分配担保失败 4.
   - DK 1.7 及以前的永久代空间不足 
   - Concurrent Mode Failure
-----

# 判断一个对象是否可被回收

* 程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。
* 垃圾回收主要是针对Java堆和方法区进行

1.引用计数算法
* 给对象中添加一个引用计数器每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能在被使用的
* 缺陷：很难解决对象间相互循环引用的问题

2.可达性分析算法
* 通过GC Roots作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收

GC用的引用可达性分析算法中，哪些对象可作为GC Roots对象？
* 虚拟机栈(栈帧中的本地变量表)中引用的对象。
* 方法区中静态属性引用的对象。
* 方法区中常量引用的对象。
* 本地方法栈中 JNI （即一般说的 Native 方法）引用的对象。
 
## 方法区的回收
Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的 “性价比” 一般比较低;

永久代的垃圾收集主要回收两部分：废弃常量 和 无用的类。
* 回收废弃常量与回收 Java 堆中的对象非常类似。
* 要判定一个类是否是 “无用的类” 的条件相对苛刻许多。类需要同时满足下面3个条件才能算 “无用的类
  * 该类的所有实例都已经被回收。
  * 加载该类的 ClassLoader 已经被回收。
  * 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 引用类型
> 将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)4种，这4种引用强度依次逐渐减弱

1. 强引用(Strong Reference)
  * java中的引用默认
  * 被强引用关联的对象不会被回收。
  * 使用new一个新对象的方式来创建强引用。
  
2. 软引用(Soft Reference）
  * 被软引用关联的对象只有在内存不够的情况下才会被回收
  * 使用`SoftReference`类来创建软引用

3.弱引用(Weak Reference)
  * 被弱引用关联的对象一定会被回收,也就是说它只能存活到下一次垃圾回收发生之前
  * 使用`WeakReference`类来实现弱引用
  
4.虚引用(Phantom Reference)
  * 一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象
  * 为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知.跟踪垃圾回收器收集对象的活动
  * 使用`PhantomReference`来实现虚引用
 

### 垃圾收集算法（垃圾处理方法)(如何回收)

1. 标记 - 清除
2. 
首先标记出所有需要回收的对象，在标记完成后统一回收所有标记的对象
* 效率问题：标记和清除都需要遍历，效率不高；
* 空间问题：标记清除之后会产生大量不连续的内存碎片，导致以后需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另外一次垃圾收集

2.标记 - 整理
* 标记过程仍然与"标记-清除"算法一样，
* 但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存
* 无需复制，保证效率。内存规整。
* 效率不如复制算法

3. 复制回收
* 将内存划分为大小相等的两块，每次只使用其中一块
* 当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理
* 简答高效，内存相对整齐
* 主要不足是只使用了内存的一半。
* .如果对象存活率高，需要复制的对象比较多，产生效率问题。

优化: 现在的商业虚拟机都采用这种收集算法来回收新生代
* 我们可以把内存划分为三块：Eden、Survior1、Survior2，大小比例为 8:1:1。
* 分配内存时只使用 Eden + Survior1
* 当这里的内存将满时，JVM 会出发一次 MinorGC，清除掉废弃对象，并将存活对象复制到另一块 Survior2 中。那么接下来就使用 Eden + Survior2 进行内存分配。

> 保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象

4. 分代收集
* 根据对象存活周期将内存划分为几块，不同块采用适当的收集算法
* 一般将堆分为新生代和老年代
* 新生代使用：复制回收 算法
* 老年代使用：因为这些对象存活率高，没有额外空间进行分配担保, 标记 - 清除 或者 标记 - 整理 算法

---
# 垃圾收集器 

<img width="488" alt="Screen Shot 2021-11-08 at 8 34 39 PM" src="https://user-images.githubusercontent.com/27160394/140743007-609d1d6f-b879-4509-9bf6-b1d5ff6fc577.png">

* 单线程与多线程：单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；
* 串行与并行：串行指的是垃圾收集器与用户程序交替执行,这意味着在执行垃圾收集的时候需要停顿用户程序;并行指的是垃圾收集器和用户程序同时执行。除了CMS和G1之外,其它垃圾收集器都是以串行的方式执行。


1.Serial

* Serial 翻译为串行，也就是说它以串行的方式执行。
* 它是单线程的收集器，只会使用一个线程进行垃圾收集工作
* 它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。
* 它是 Client 模式下的默认新生代收集器

<img width="433" alt="Screen Shot 2021-11-14 at 7 03 46 PM" src="https://user-images.githubusercontent.com/27160394/141678253-17925a7f-98b8-4d8a-983e-1908e24dfebc.png">

2.ParNew
* Serial 收集器的多线程版本
* Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作
* 所以在 JDK1.5中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个

<img width="422" alt="Screen Shot 2021-11-14 at 7 04 33 PM" src="https://user-images.githubusercontent.com/27160394/141678279-19b23aef-1e47-4945-82cd-94ddce0ab74e.png">

3.Parallel Scavenge
* Parallel Scavenge 收集器是一个新生代收集器，
* 使用复制算法的收集器，又是并行的多线程收集器
* 它的目标是达到一个可控制的吞吐量，它被称为吞吐量优先收集器.(其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间(响应时间))
* 高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。
* Parallel Scavenge 收集器气提供了两个参数用于精确控制吞吐量
  * 最大垃圾收集停顿时间：`-XX:MaxGCPauseMills`
  * 吞吐量大小：`-XX:GCTimeRatio`
 
```
吞吐量指 CPU 用于运行用户代码的时间占总时间的比值
吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)
停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务
缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。
```

4.Serial Old
*  Serial 收集器的老年代版本，它同样是一个单线程收集器，使用 ”标记-整理“ 算法。
*  在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用
*  作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

5.Parallel Old
* Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和 ”标记-整理“ 算法
* 在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

6.CMS
* Mark Sweep指的是标记-清除算法. 
* 主要优点：并发收集、低停顿，Sun公司也称之为并发低停顿收集器（Concurrent Low Pause Collection）

<img width="509" alt="Screen Shot 2021-11-14 at 7 15 32 PM" src="https://user-images.githubusercontent.com/27160394/141678598-aafe659a-492e-4a78-aea2-aa390d8b58ba.png">


```
高吞吐量"和"低暂停时间"是一对相互竞争的目标(矛盾)。
* 因为如果选择以吞吐量优先,那么必然需要降低内存回收的执行频率,但是这样会导致GC需要更长的暂停时间来执行内存回收。
* 相反的,如果选择以低延迟优先为原则,那么为了降低每次执行的内存回收时的暂停时间,也只能频繁地执行内存回收,但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。

```
分为以下四个流程：
1. 初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要停顿。
2. 并发标记：进行GC Roots Tracing的过程，它在整个回收过程中耗时最长，不需要停顿。
3. 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
4. 并发清除：不需要停顿。

缺点
* 吞吐量低: 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高.
* 标记-清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC
* 无法处理浮动垃圾，指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收
  * 由于浮动垃圾的存在，因此需要预留出一部分内存,如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。

7.G1
oracle 官方计划在 jdk9 中将 G1 变成默认的垃圾收集器
* G1将新生代,老年代的物理空间划分取消了
* G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离
  * 从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能
* 每个 Region都有一个Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描
* 维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region

<img width="596" alt="Screen Shot 2021-11-14 at 7 27 27 PM" src="https://user-images.githubusercontent.com/27160394/141678922-0847b74e-4c25-482d-bb16-d9fe9e216bbf.png">

过程
1. 初始标记： 这个阶段是STW(Stop the World )的，所有应用线程会被暂停，标记出从GC Root开始直接可达的对象
2. 并发标记： 从GC Roots开始对堆中对象进行可达性分析，找出存活对象，耗时较长。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。
3. 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
4. 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

优点
* 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。
* 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。
----
# 内存分配与回收策略

## Minor GC，Full GC
* Minor GC：发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。
  * 新生代中的垃圾收集动作，采用的是复制算法
  * 对于较大的对象,在 Minor GC 的时候可以直接进入老年代
* Full GC：发生在老年代上，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多
  * Full GC 是发生在老年代的垃圾收集动作，采用的是 标记-清除/整理 算法。
  * 由于老年代的对象几乎都是在 Survivor 区熬过来的，不会那么容易死掉。因此 Full GC 发生的次数不会有 Minor GC 那么频繁，
  *  Time(Full GC)>Time(Minor GC)


## 内存分配策略
1. 对象优先在 Eden 分配
2. 大对象直接进入老年代, 需要连续内存空间的对象,最典型的大对象是那种很长的字符串以及数组。
3. 长期存活的对象进入老年代
   * 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中
4. 动态对象年龄判定
  * 如果在Survivor中相同年龄所有对象大小的总和大于Survivor空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代,无需等到 MaxTenuringThreshold 中要求的年龄
6. 空间分配担保
  * 在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。
  * 如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败,如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小
  * 如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。


## Full GC 的触发条件
> 对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂
1.`System.gc()`:只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存
2.老年代空间不足: 可以通过 `-Xmn` 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代
3.使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC
4.Concurrent Mode Failure:执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足(可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足)，便会报 Concurrent Mode Failure 错误，并触发 Full GC

---
# G1

* G1回收是“选择一些内存块”，而不是整代内存来回收，这是G1跟其它GC非常不同的一点，
* 其它GC每次回收都会回收整个Generation的内存(Eden, Old), 而回收内存所需的时间就取决于内存的大小，以及实际垃圾的多少，所以垃圾回收时间是不可控的；
* 而G1每次并不会回收整代内存，到底回收多少内存就看用户配置的暂停时间，配置的时间短就少回收点，配置的时间长就多回收点，伸缩自如

三色标记是在cms和g1中使用的垃圾追踪算法
* 黑色：从GCRoots开始,已扫描过它全部引用的对象,标记为黑色
* 灰色： 扫描过对象本身,还没完全扫描过它全部引用的对象,标记为灰色
* 白色： 还没扫描过的对象,标记为白色

1. 初始时，所有对象都在 【白色集合】中；
2.将GC Roots 直接引用到的对象 挪到 【灰色集合】中；
3.从灰色集合中获取对象：将本对象 引用到的 其他对象 全部挪到 【灰色集合】中；将本对象 挪到 【黑色集合】里面。重复步骤3，直至【灰色集合】为空时结束


漏标的两个充要条件
* 有至少一个黑色对象在自己被标记之后指向了这个白色对象
* 所有的灰色对象在自己引用扫描完成之前删除了对白色对象的引用

漏标问题如何解决的
* G1采用的是原始快照(STAB)
* 我们在这个灰色对象取消对白色对象的引用之前,将这个引用记录下来,在最后标记的时候,再以这个引用指向的白色对象为根,对它的引用进行扫描(当一个灰色对象取消了对白色对象的引用,那么这个白色对象被变灰)
* 缺点： 这个白色对象有可能并没有黑色对象去引用它,但是它还是被变灰了,就会导致它和它的引用,本来应该被垃圾回收掉,但是此次GC存活了下来,就是所谓的浮动垃圾

CMS采用的是增量更新
* 我们在这个黑色对象增加了对白色对象的引用之后,将它的这个引用,记录下来,在最后标记的时候,再以这个黑色对象为根,对它的引用进行重新扫描
* 当一个黑色对象增加了对白色对象的引用,那么这个黑色对象就被变灰
* 这样有一个缺点,就是会重新扫描这个黑色对象的所有引用,比较浪费时间



