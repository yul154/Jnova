
运行时数据区 
* 程序计数器 
  * 作用 
  * 概述
* 虚拟机栈 
    * 概述 
    * 栈的存储单位 
    * 栈运行原理 
    * 栈帧的内部结构 
      * 局部变量表
        * 槽 Slot 
      * 操作数栈 
        * 概述 
        * 栈顶缓存（Top-of-stack-Cashing）
      * 动态链接（指向运行时常量池的方法引用） 
        * JVM 是如何执行方法调用的 
        * 虚方法和非虚方法 
        * 虚方法表 
        * 方法返回地址（return address） 
* 本地方法栈
  * 本地方法接口
  * 本地方法栈（Native Method Stack）
* 堆内存 
    * 内存划分 
       * 年轻代 (Young Generation) 
       * 老年代(Old Generation)
       * 元空间
       * 设置堆内存大小和 OOM 
          * 查看 JVM 堆内存分配 
    * 对象在堆中的生命周期
    * 对象的分配过程
    * GC 垃圾回收
      * Minor GC、Major GC、Full GC
    * TLAB
        *  什么是 TLAB （Thread Local Allocation Buffer）? 
        *  为什么要有 TLAB
    * 堆是分配对象存储的唯一选择吗 
      * 逃逸分析 
        * 代码优化之同步省略（消除） 
        * 代码优化之标量替换 
        * 代码优化之栈上分配

* 方法区 
  * 设置方法区内存的大小 
  * 方法区内部结构 
    * 类型信息 
    * 域（Field）信息 
    * 方法（Method）信息 
  * 运行时常量池 
    * 常量池 为什么需要常量池？ 
    * 运行时常量池 
  * 方法区在 JDK6、7、8中的演进细节 移除永久代原因
  * 方法区的垃圾回收

![image](https://user-images.githubusercontent.com/27160394/145221819-0c2ffafb-4045-42c6-8a38-625069424ea7.png)

------
# 运行时数据区(JVM RUNTIME data areas)

* 线程私有：程序计数器、虚拟机栈、本地方法区
* 线程共享：堆、方法区, 堆外内存（Java7的永久代或JDK8的元空间、代码缓存）

* 方法区 —— 所有类级数据都将存储在这里，包括静态变量。每一个JVM只有一个方法区，并且它是一个共享资源。
* 堆区 —— 所有对象及其对应的实例变量和数组等存储在此，每个JVM只有一个堆区。由于方法区和堆区是多线程内存共享，因此存储的数据是非线程安全的。
* 栈区 —— 每个线程都会创建一个单独的运行时栈。在每一次方法调用，都会在栈内存中创建一个栈帧(Stack Frame)。所有局部变量将在栈内存中创建。栈区是线程安全的，因为它不是一个共享资源。栈帧可以被划分为三个实体：
    * 局部变量数组 —— 与方法中有多少局部变量有关，相应的值将存储在此处。 
    * 操作数栈 —— 如果任何的中间操作需要被执行，操作数栈将作为运行时工作区来执行操作。 
    * 帧数据 —— 与方法相对应的所有符号存储在此。在任何异常情况下，catch块的信息被保留在帧数据中。
* PC寄存器(Program Counter Register) —— 每一个线程都有单独的PC寄存器，一旦执行指令，PC寄存器将被下一条指令更新，保存当前执行指令的地址。
* 本地方法栈 —— 本地方法栈保存本地方法信息，每一个线程都会创建一个单独的本地方栈。

----
# 程序计数器(PC Registers)
> 用于记录当前线程的正在执行的字节码指令位置,不同线程的执行位置都需要记录下来，因此程序计数器是线程私有的

因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令

> 它是唯一一个在 JVM 规范中没有规定任何 OutOfMemoryError 情况的区域

----
# 虚拟机栈(Stack area): 
> 每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame)对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。

* 主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。
* JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着入栈（进栈/压栈），方法执行结束出栈
* 栈不存在垃圾回收问题

Java 虚拟机规范允许 Java虚拟机栈的大小是动态的或者是固定不变的
  * 如果采用固定大小的 Java 虚拟机栈, 线程请求的栈的深度大于虚拟机允许的深度，将抛出`StackOverFlowError`异常（栈溢出）
  * 如果虚拟机栈可以动态扩展,扩展时无法申请到足够的内存空间，就会抛出`OutOfmMemoryError`异常(没有足够的内存） 

可以通过参数`-Xss`来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度

## Stack Frame
>  栈的存储单位

* 每个线程都有自己的栈
* 栈中的数据都是以栈帧（Stack Frame）的格式存在 
* 在这个线程上正在执行的每个方法都各自有对应的一个栈帧 
* 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息

### 栈帧的内部结构

* 局部变量表（Local Variables）: 是一组变量值存储空间，主要用于存储方法参数和定义在方法体内的局部变量 
    * 局部变量表最基本的存储单元是 Slot(变量槽):每一个 Slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值 
* 操作数栈（Operand Stack): 主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间
* 动态链接（Dynamic Linking）：指向运行时常量池的方法引用 
* 方法返回地址（Return Address）：方法正常退出或异常退出的地址,用来存放调用该方法的 PC 寄存器的值

###  栈运行原理
* JVM 直接对 Java 栈的操作只有两个，对栈帧的压栈和出栈，遵循“先进后出/后进先出”原则
* 在一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）
* 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧
* Java 方法有两种返回函数的方式，一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出

-----
# 本地方法栈(native method stack )

## 本地方法接口
> 一个 Native Method 就是一个 Java 调用非 Java 代码的接口

**为什么要使用本地方法（Native Method）?**
* 与 Java 环境外交互：有时 Java 应用需要与 Java 外面的环境交互，这就是本地方法存在的原因
*  JVM 的一些部分就是 C 语言写的
*  Sun的解释器就是C实现的，这使得它能像一些普通的C一样与外部交互

## 本地方法栈（Native Method Stack）

本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存

----
#  堆
> 所有对象实例都在这里分配内存

## 内存划分

<img width="450" alt="Screen Shot 2021-12-08 at 10 29 10 PM" src="https://user-images.githubusercontent.com/27160394/145225590-0a5457f9-e3e5-4cca-a378-ce7ff070c6fa.png">

虚拟机把堆内存逻辑上划分成三块区域(分代的唯一理由就是优化 GC 性能)
* 新生代(Young Generation): 在方法中去 new 一个对象，那这方法调用完毕后，对象就会被回收，这就是一个典型的新生代对象
* 老年代(Old Generation): 在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。而且大对象直接进入老年代,当 Survivor 空间不够用时，需要依赖于老年代进行分配担保，所以大对象直接进入老年代
* 永久代(Permanent Generation):即方法区。



可以通过`-Xms`和`-Xmx`两个虚拟机参数来指定一个程序的 Java 堆内存大小，第一个参数设置初始值，第二个参数设置最大值
```
java -Xms=1M -Xmx=2M HackTheJava
```

### 年轻代 (Young Generation)
> 年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集`Minor GC`

新生代存放着大量的生命很短的对象，因此新生代在三个区域中垃圾回收的频率最高。为了更高效地进行垃圾回收，把新生代继续划分成以下三个空间：
* Eden（伊甸园）
* From Survivor（幸存者）
* To Survivor


> 为什么年轻代要分三个空间
* 因为新生代gc比较频繁、对象存活率低，用复制算法在回收时的效率会更高，也不会产生内存碎片。
* 复制算法的代价就是要将内存折半，为了不浪费过多的内存，就划分了两块相同大小的内存区域`survivor from`和`survivor to`


> 年轻代如何进入老年代
* 虚拟机给每个对象定义了一个对象年龄计数器
* 在对象在Eden创建并经过第一次Minor GC后仍然存活，并能被Suivivor容纳的话，将会被移动到Survivor空间，并对象年龄设置为1。
* 每经历过Minor GC，年龄就增加1岁，当到一定程度（默认15岁，
* 可以通过参数`-XXMaxTenuringThreshold设置`，就将会晋升年老代。


### 老年代(Old Generation)
> 旧的一代内存包含那些经过许多轮minor GC 后仍然存活的对象.通常,垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主GC（Major GC），通常需要更长的时间

* 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个Survivor 区之间发生大量的内存拷贝



### 元空间
* 不管是 JDK8 之前的永久代，还是 JDK8 及以后的元空间，都可以看作是 Java 虚拟机规范中方法区的实现
* 虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。

## OOM

通过`-Xmx`和`-Xms`来设定
* `-Xms`用来表示堆的起始内存，等价于 -XX:InitialHeapSize 
* `-Xmx` 用来表示堆的最大内存，等价于 -XX:MaxHeapSize

如果堆的内存大小超过 -Xmx 设定的最大内存,就会抛出 OutOfMemoryError 异常。


### 查看 JVM 堆内存分配
1. 在默认不配置 JVM 堆内存大小的情况下，JVM 根据默认值来配置当前内存大小
2. 默认情况下新生代和老年代的比例是 1:2，可以通过 `–XX:NewRatio` 来配置
  * 新生代中的 Eden:From Survivor:To Survivor 的比例是 8:1:1，可以通过 `-XX:SurvivorRatio`来配置 
3. `-XX:+UseAdaptiveSizePolicy`，JVM 会动态调整 JVM 堆中各个区域的大小以及进入老年代的年龄


###  对象在堆中的生命周期
1. 当创建一个对象时，对象会被优先分配到新生代的 Eden 区
  * 此时 JVM 会给对象定义一个对象年轻计数器`-XX:MaxTenuringThreshold`
2. 当 Eden 空间不足时，JVM 将执行新生代的垃圾回收Minor GC
  * JVM会把存活的对象转移到 Survivor 中，并且对象年龄 +1
  * 对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会+1 
3. 如果分配的对象超过了-XX:PetenureSizeThreshold，对象会直接被分配到老年代 

### 对象的分配过程
* 当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC）将伊甸园区中的不再被其他对象所引用的对象进行销毁。
* 再加载新的对象放到伊甸园区 然后将伊甸园中的剩余对象移动到幸存者 0 区 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区，
* 如果没有回收，就会放到幸存者1区 如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区 
* 什么时候才会去养老区呢？ 默认是 15 次回收标记 在养老区，相对悠闲。
* 当养老区内存不足时，再次触发 Major GC，进行养老区的内存清理 
* 若养老区执行了 Major GC  之后发现依然无法进行对象的保存，就会产生 OOM 异常
----
# 方法区(Method area)
> 运行时常量池,用于存储已被虚拟机加载的类信息，常量，静态变量。

*  Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。
*  运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本/字段/方法/接口等描述信息外，还有一项信息是常量池Constant Pool Table,用于存放编译期生成的各种字面量和符号引用
*  方法区的大小和堆空间一样，可以选择固定大小也可选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误


## Puzzle word

* 方法区（method area）只是 JVM 规范中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。
* 永久代（PermGen)是Hotspot 虚拟机特有的概念， Java8 的时候又被元空间取代了，永久代和元空间都可以理解为方法区的落地实现。
* 永久代物理是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 JVM 限制了，也比较难发生OOM
* Java7 中我们通过`-XX:PermSize`和`-xx:MaxPermSize`来设置永久代参数，Java8 之后，随着永久代的取消，这些参数也就随之失效了，改为通过`-XX:MetaspaceSize`和`-XX:MaxMetaspaceSize`用来设置元空间参数
* 存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中


> 设置方法区内存的大小
* 元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 指定，替代上述原有的两个参数

## 方法区内部结构
* 类型信息
  * 这个类型的完整有效名称（全名=包名.类名） 
  * 这个类型直接父类的完整有效名（对于 interface或是 java.lang.Object，都没有父类） 
  * 这个类型的修饰符（public，abstract，final 的某个子集） 
  * 这个类型直接接口的一个有序列表
* 域（Field）信息
  *  JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序 
  *  域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient 的某个子集） ¶

* 方法（Method）信息
  * 方法名称 
  * 方法的返回类型 
  * 方法参数的数量和类型 
  * 方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集） 
  * 方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外） 
  * 异常表（abstract 和 native 方法除外）
      * 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引

## 方法区的垃圾回收
> 常量池中废弃的常量和不再使用的类型。

常量池之中主要存放的两大类常量
* 字面量: Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值
* 符号引用
  * 类和接口的全限定名
  * 字段的名称和描述符
  * 方法的名称和描述符

只要常量池中的常量没有被任何地方引用，就可以被回收

判定一个类型是否属于“不再被使用的类”，需要同时满足三个条件：
*  该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例 
*  加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常很难达成 
*  该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

-


