> 类加载机制
Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的加载机制

> 如何打破双亲委派


> 垃圾回收算法
> 垃圾回收器
> GC ROOT有哪些
> CMS 和ZGC的区别

> 了解 java 的堆和栈吗

* 功能不同
  * 栈内存用来存储局部变量和方法调用。
  * 而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。

* 共享性不同
  * 栈内存是线程私有的。
  * 堆内存是所有线程共有的。

* 异常错误不同
  * 如果栈内存或者堆内存不足都会抛出异常。栈空间不足：java.lang.StackOverFlowError。堆空间不足：java.lang.OutOfMemoryError。
* 空间大小
  * 栈的空间大小远远小于堆的。



> fullgc怎么解决

Full GC：通常意义上而言指的是一次特殊GC的行为描述，这次GC会回收整个堆的内存，包含老年代，新生代，metaspace

* 在代码中调用`System.gc()`方法会建议JVM进行Full GC，但是注意这只是建议，JVM执行不执行是另外一回事儿,不过在大多数情况下会增加Full GC的次数，导致系统性能下降，可以通过`-XX:+ DisableExplicitGC`来禁止RMI调用`System.gc`
* 老年代空间不足: 可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代,及不要创建过大的对象及数组。
  * 系统并发高,执行耗时过长,或者数据量过大,导致 young gc频繁,且gc后存活对象太多，但是survivor\区存放不下导致对象快速进入老年代 老年代迅速堆满

> 你们垃圾回收器用的什么？ G1有哪些特点？G1如何实现可预测的停顿时间？漏标问题如何解决的？介绍下三色标记？说说STAB算法？
* Serial, ParNew,Parallel Scavenge(复制),Serial Old,Parallel Old，CMS(标记清理)，G1

* G1将新生代,老年代的物理空间划分取消了，G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离
* 整体上可以看作是整理算法，可以避免内存碎片化
* G1实现可预测的停顿时间


1.初始标记：在垃圾回收的最开始有一个短暂的时间段(Inital Mark)会停止应用(stop-the-world)
2.并发标记：然后应用继续运行，同时G1开始Concurrent Mark
3.最终标记：再次停止应用，来一个Final Mark (stop-the-world)
4.根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的

* G1回收是“选择一些内存块”，而不是整代内存来回收，这是G1跟其它GC非常不同的一点，
* 其它GC每次回收都会回收整个Generation的内存(Eden, Old), 而回收内存所需的时间就取决于内存的大小，以及实际垃圾的多少，所以垃圾回收时间是不可控的；
* 而G1每次并不会回收整代内存，到底回收多少内存就看用户配置的暂停时间，配置的时间短就少回收点，配置的时间长就多回收点，伸缩自如

三色标记是在cms和g1中使用的垃圾追踪算法
* 黑色：从GCRoots开始,已扫描过它全部引用的对象,标记为黑色
* 灰色： 扫描过对象本身,还没完全扫描过它全部引用的对象,标记为灰色
* 白色： 还没扫描过的对象,标记为白色

漏标的两个充要条件
* 有至少一个黑色对象在自己被标记之后指向了这个白色对象
* 所有的灰色对象在自己引用扫描完成之前删除了对白色对象的引用

漏标问题如何解决的
* G1采用的是原始快照(STAB)
* 我们在这个灰色对象取消对白色对象的引用之前,将这个引用记录下来,在最后标记的时候,再以这个引用指向的白色对象为根,对它的引用进行扫描(当一个灰色对象取消了对白色对象的引用,那么这个白色对象被变灰)
* 缺点： 这个白色对象有可能并没有黑色对象去引用它,但是它还是被变灰了,就会导致它和它的引用,本来应该被垃圾回收掉,但是此次GC存活了下来,就是所谓的浮动垃圾

CMS采用的是增量更新
* 我们在这个黑色对象增加了对白色对象的引用之后,将它的这个引用,记录下来,在最后标记的时候,再以这个黑色对象为根,对它的引用进行重新扫描
* 当一个黑色对象增加了对白色对象的引用,那么这个黑色对象就被变灰
* 这样有一个缺点,就是会重新扫描这个黑色对象的所有引用,比较浪费时间

介绍下三色标记
1. 初始时，所有对象都在 【白色集合】中；
2.将GC Roots 直接引用到的对象 挪到 【灰色集合】中；
3.从灰色集合中获取对象：将本对象 引用到的 其他对象 全部挪到 【灰色集合】中；将本对象 挪到 【黑色集合】里面。重复步骤3，直至【灰色集合】为空时结束
