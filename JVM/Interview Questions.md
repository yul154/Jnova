> 类加载机制
Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的加载机制

> 如何打破双亲委派


> 垃圾回收算法
> 垃圾回收器
> GC ROOT有哪些
> CMS 和ZGC的区别

> 了解 java 的堆和栈吗

* 功能不同
  * 栈内存用来存储局部变量和方法调用。
  * 而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。

* 共享性不同
  * 栈内存是线程私有的。
  * 堆内存是所有线程共有的。

* 异常错误不同
  * 如果栈内存或者堆内存不足都会抛出异常。栈空间不足：java.lang.StackOverFlowError。堆空间不足：java.lang.OutOfMemoryError。
* 空间大小
  * 栈的空间大小远远小于堆的。



> fullgc怎么解决

Full GC：通常意义上而言指的是一次特殊GC的行为描述，这次GC会回收整个堆的内存，包含老年代，新生代，metaspace

* 在代码中调用`System.gc()`方法会建议JVM进行Full GC，但是注意这只是建议，JVM执行不执行是另外一回事儿,不过在大多数情况下会增加Full GC的次数，导致系统性能下降，可以通过`-XX:+ DisableExplicitGC`来禁止RMI调用`System.gc`
* 老年代空间不足: 可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代,及不要创建过大的对象及数组。
  * 系统并发高,执行耗时过长,或者数据量过大,导致 young gc频繁,且gc后存活对象太多，但是survivor\区存放不下导致对象快速进入老年代 老年代迅速堆满

