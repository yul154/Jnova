<img width="1029" alt="Screen Shot 2021-12-08 at 8 39 08 PM" src="https://user-images.githubusercontent.com/27160394/145209768-b8bc7c05-768b-4aaf-8ea4-a036022a700a.png">


JVM 基础 - Java 类加载机制 
* 类的生命周期 
  * 类的加载: 查找并加载类的二进制数据 
  * 连接 
    * 验证: 确保被加载的类的正确性 
    * 准备: 为类的静态变量分配内存，并将其初始化为默认值 
    * 解析: 把类中的符号引用转换为直接引用 
  * 初始化 
  * 使用 
  * 卸载 
* 类加载器， JVM类加载机制 
    * 类加载器的层次 
    * 寻找类加载器 
    * 类的加载 
    * JVM类加载机制 
    * 自定义类加载器 


-----
# 类的生命周期

虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机类加载机制

<img width="450" alt="Screen Shot 2021-11-14 at 7 48 03 PM" src="https://user-images.githubusercontent.com/27160394/141679513-e7c153f5-386e-4c25-85c8-59d2dab6c037.png">

1. 加载（Loading）
2. 连接
    1. 验证（Verification）
    2. 准备（Preparation）
    3. 解析（Resolution）
5. 初始化（Initialization）
6. 使用（Using）
7. 卸载（Unloading）


### 1. 加载
> 查找并加载类的二进制数据

加载过程完成以下三件事
1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构
3. 在Java堆中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口

加载阶段(准确地说，是加载阶段获取类的二进制字节流的动作)是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载

加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据

对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在就Java虚拟机中的唯一性，也就是说，即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的`equals(),isAssignableFrom(),isInstance()`等方法的返回结果


> 加载.class文件的方式

* 从本地系统中直接加载
* 通过网络下载.class文件
* 从zip，jar等归档文件中加载.class文件
* 从专有数据库中提取.class文件
* 将Java源文件动态编译为.class文件


### 2.连接

1. 校验 —— 确保加载的类的正确性，如果校验失败，我们将获得校验错误信息。
2. 准备 —— 类中的静态变量分配内存，并且其初始化为默认值。
3. 解析 —— 把类中的符号引用变为直接引用。

**1.验证**
> 确保`Class`文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全

1. 文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。
2. 元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。
3. 字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。
4. 符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。


**2.准备**
> 为类的静态变量分配内存，并将其初始化为默认值

* 这些变量使用的内存都将在**方法区**中进行分配。
* 类变量是被`static`修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存
* 实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在堆
* 实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次
* 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值


**3.解析**
> 虚拟机将常量池的符号引用替换为直接引用的过程

* 类或接口的解析
* 字段解析
* 类方法解析
* 接口方法解析

*符号引用和直接引用？*

* 符号引用：符号引用是一组符号来描述所引用的目标对象，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标对象并不一定已经加载到内存中
* 直接引用：直接引用可以是直接指向目标对象的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机内存布局实现相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同，如果有了直接引用，那引用的目标必定已经在内存中存在。

符号引用就是字符串,这个字符串包含足够的信息,以供实际使用时可以找到相应的位置


### 3.初始化
> 这是类加载的最后阶段，所有的静态变量都将被分配原值，静态代码块将被执行。

JVM初始化步骤
1. 假如这个类还没有被加载和连接，则程序先加载并连接该类
2. 假如该类的直接父类还没有被初始化，则先初始化其直接父类
3. 假如类中有初始化语句，则系统依次执行这些初始化语句

类初始化时机: 只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种:
* 创建类的实例，也就是new的方式 
* 访问某个类或接口的静态变量，或者对该静态变量赋值 
* 调用类的静态方法 
* 反射(如Class.forName("com.pdai.jvm.Test")) 
* 初始化某个类的子类，则其父类也会被初始化 
* Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类

```
1.主动引用: 虚拟机规范严格规定了有且只有下列五种情况必须对类进行初始化(加载、验证、准备都会随之发生)
 * 遇到`new、getstatic、putstatic、invokestatic`这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。
   * 最常见的生成这4条指令的场景是：`new`实例化对象的时候,读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。
 * 使用`java.lang.reflect`包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化 
 * 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
 * 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类
 * 如果`java.lang.invoke.MethodHandle`实例最后的解析结果为`REF_getStatic, REF_putStatic,REF_invokeStatic`的方法，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化

2.被动引用:以上5种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用
 * 通过子类引用父类的静态字段，不会导致子类初始化
 * 通过数组定义来引用类，不会触发此类的初始化
 * 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化

```

```
 初始化阶段才真正开始执行类中定义的Java程序代码。初始化阶段即虚拟机执行类构造器`<clinit>()`方法的过程。
`<clinit>()`方法的执行规则:
* 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。
* 与类的构造函数（或者说实例构造器 <init>()）不同，不需要显式的调用父类的构造器。虚拟机会自动保证在子类的`<clinit>()`方法运行之前，父类的`<clinit>()`方法已经执行结束。因此虚拟机中第一个执行 <clinit>() 方法的类肯定为 java.lang.Object。
* 由于父类的`<clinit>()`方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。
* `<clinit>()` 方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成 <clinit>() 方法。
* 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 `<clinit>()`方法。但接口与类不同的是，执行接口的`<clinit>() ]`方法不需要先执行父接口的 <clinit>() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <clinit>() 方法。
 * 虚拟机会保证一个类的`<clinit>()`方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的`<clinit>()`方法，其它线程都会阻塞等待，直到活动线程执行 `<clinit>()`方法完毕。如果在一个类的 <clinit>() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。
```` 

### 4.使用
类访问方法区内的数据结构的接口， 对象是Heap区的数据。

### 5.卸载
Java虚拟机将结束生命周期的几种情况

* 执行了System.exit()方法
* 程序正常执行结束
* 程序在执行过程中遇到了异常或错误而异常终止
* 由于操作系统出现错误而导致Java虚拟机进程终止


#### `Student s = new Student();`在内存中做了哪些事情

1. 加载 Student.class 文件进内存
2. 在栈内存为 s 开辟空间
3. 在堆内存为 Student 对象开辟空间
4. 对Student 对象的成员变量进行默认初始化
5. 对Student 对象的成员变量进行显示初始化
6. 通过构造方法对 Student 对象的成员变量赋值
7, Student 对象初始化完毕，把对象地址赋值给 s 变量


  
-----
# 类加载器
> 虚拟机设计团队把类加载阶段中的"获取描述此类的二进制字节流”放到 Java 虚拟机外部去实现,以便让应用程序自己决定如何去获取所需要的类.实现这个动作的代码模块称为 “类加载器”
 
**类加载器的层次**

从 Java 开发人员的角度看
* 启动类加载器（Bootstrap ClassLoader): 是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库
  * 此类加载器负责将存放在 `负责加载存放在JDK\jre\lib`目录中的
  * 启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可
* 扩展类加载器（Extension ClassLoader):负责加载Java的扩展类库，默认加载`JAVA_HOME/jre/lib/ext/`目下的所有jar
  * 它负责将 <JAVA_HOME>/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中
  * 开发者可以直接使用扩展类加载器
* 应用程序类加载器（Application ClassLoader):负责加载应用程序classpath目录下的所有jar和class文件。
  * 它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器
* 自定义类加载器
  * 载器步骤：
    1.定义一个类，继承 ClassLoader
    2.重写 loadClass 方法
    3.实例化 Class 对象
  * 自定义类加载器的优势: 高度的灵活性,通过自定义类加载器可以实现热部署,代码加密
 
> 双亲委派模型中，类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码的。

对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在就Java虚拟机中的唯一性，也就是说，即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的`equals(),isAssignableFrom(),isInstance()`等方法的返回结果


类加载有三种方式:

1、命令行启动应用时候由JVM初始化加载

2、通过`Class.forName()`方法动态加载

3、通过`ClassLoader.loadClass()`方法动态加载

> `Class.forName()`和`ClassLoader.loadClass()`区别?

* `Class.forName()`: 将类的`.class`文件加载到jvm中之外，还会对类进行解释，执行类中的static块；
* `ClassLoader.loadClass()`: 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。
* `Class.forName(name, initialize, loader)`带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。 ¶

> 为什么重写loadClass方法可以破坏双亲委派，这个方法和findClass()、defineClass()区别是什么


```
因为他的双亲委派过程都是在loadClass方法中实现的，那么想要破坏这种机制，那么就自定义一个类加载器，重写其中的loadClass方法，使其不进行双亲委派即可。
```

* loadClass() ->就是主要进行类加载的方法，默认的双亲委派机制就实现在这个方法中。
* definclass(): 把字节码转化为Class
* findClass(): 根据名称或位置加载.class字节码,然后使用defineClass
```
如果你想定义一个自己的类加载器，并且要遵守双亲委派模型，那么可以继承ClassLoader，并且在findClass中实现你自己的加载逻辑即可
```


----
# JVM类加载机制 

* 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入 
* 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类 
* 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效 
* 双亲委派机制, 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。


双亲委派优势
* 主要是为了避免重复加载的问题,系统类防止内存中出现多份同样的字节码
  * 如果没有双亲委派机制，同一个类可能就会被多个类加载器加载，如此类就可能会被识别为两个不同的类，相互赋值时问题就会出现。
* 双亲委派机制能够保证多加载器加载某个类时，最终都是由一个加载器加载，确保最终加载结果相同


### 双亲委派是怎么实现的？

实现双亲委派模型的代码都集中在`java.lang.ClassLoader`的`loadClass()`
1. 首先检查这个类是否已经被加载过了（是否在虚拟机中已经存在了），若已经加载了，就直接进返回。
2. 若没有加载，则调用父类加载器的`loadClass()`方法去尝试加载。
3. `class loader`如父类加载器为空，则使用启动类加载器去尝试加载。
4. 如果父类加载器加载失败，则抛出 ClassNotFoundException 异常后，使用自己的 findClass() 方法进行加载。

> 双亲委派被破坏的例子
* 是JNDI、JDBC等需要加载SPI接口实现类的情况
* 为什么Tomcat要破坏双亲委派:
  *  一个web容器可能需要部署多个应用程序
  *  不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的
  *  如果采用默认的双亲委派类加载机制，那么是无法加载多个相同的类。
  *  所以，Tomcat破坏双亲委派原则，提供隔离的机制，为每个web容器单独提供一个WebAppClassLoader加载器


> 为什么重写loadClass方法可以破坏双亲委派，这个方法和findClass()、defineClass()区别是什么

因为他的双亲委派过程都是在loadClass方法中实现的，那么想要破坏这种机制，那么就自定义一个类加载器，重写其中的loadClass方法，使其不进行双亲委派即可。

* loadClass() ->就是主要进行类加载的方法，默认的双亲委派机制就实现在这个方法中。
* definclass(): 把字节码转化为Class
* findClass(): 根据名称或位置加载.class字节码,然后使用defineClass


如果你想定义一个自己的类加载器，并且要遵守双亲委派模型，那么可以继承`ClassLoader`，并且在`findClass`中实现你自己的加载逻辑即可





