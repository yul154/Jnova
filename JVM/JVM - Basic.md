**JVM**
* JVM 框架
* 运行事数据区域
* GC
* 内存分配与回收策略
* 类加载机制
* 虚拟机工具

<img width="534" alt="Screen Shot 2021-11-14 at 6 15 11 PM" src="https://user-images.githubusercontent.com/27160394/141676852-cb2dfe89-c541-4fc5-8161-a9e98577f9a7.png">

----
# 框架

## 1. JVM框架
> JVM 基本结构
* 类加载器
* 执行引擎
* 运行时数据区
* 本地接口

Class Files -> ClassLoader -> 运行时数据区 -> 执行引擎，本地库接口 -> 本地方法库

## JVM体系结构
<img width="509" alt="Screen Shot 2021-11-08 at 5 02 15 PM" src="https://user-images.githubusercontent.com/27160394/140713405-b15c174b-2d32-4bc3-85b1-1dfd9ed0785b.png">

## JVM各个模块

* 运行时数据区(JVM RUNTIME data areas): 经过编译生成的字节码文件（class文件），由 class loader（类加载子系统）加载后交给执行引擎执行。在执行引擎执行的过程中产生的数据会存储在一块内存区域。这块内存区域就是运行时区域
* 程序计数器(PC Registers): 用于记录当前线程的正在执行的字节码指令位置,不同线程的执行位置都需要记录下来，因此程序计数器是线程私有的
* 虚拟机栈(Stack area): 虚拟机栈是 Java 方法执行的内存结构,虚拟机会在每个 Java 方法执行时创建一个“栈桢”，用于存储局部变量表，操作数栈，动态链接，方法出口等信息。当方法执行完毕时，该栈桢会从虚拟机栈中出栈
  * 局部变量表包含基本数据类型和对象引用
  * 在 Java 虚拟机规范中，对这个区域规定了两种异常状态：
    * 如果线程请求的栈的深度大于虚拟机允许的深度，将抛出 StackOverFlowError 异常（栈溢出）
    * 如果虚拟机栈可以动态扩展,如果扩展时无法申请到足够的内存空间，就会抛出 OutOfmMemoryError 异常(没有足够的内存） 
* 本地方法栈(native method stack )：类似 Java 方法的执行有虚拟机栈，执行的是Native(一个Java调用非Java代码的接囗)方法服务
* 方法区(Method area)：运行时常量池,用于存储已被虚拟机加载的类信息，常量，静态变量。线程共享（看存储的数据就知道了）
* 堆(Heap):堆的主要作用是存放程序运行过程中创建的对象实例，
  * 因为要存放的对象实例有可能会极多，因此也是虚拟机内存管理中最大的一块。
  * 并且由于硬件条件有限，所以需要不断回收已“无用”的实例对象来腾出空间给新生成的实例对象；
  * 因此 Java 的垃圾回收主要是针对堆进行回收的（还有方法区的常量池），Java 堆很多时候也被称为GC堆（Garbage Collected Heap）
* 类加载机制(Class Loader)：类加载子系统是根据一个类的全限定名来加载该类的二进制流到内存中(动态加载class文件到内存当中用的)
  * 在JVM中将形成一份描述Class结构的元信息对象(方法区)
  * 通过该元信息对象可以获知Class的结构信息：如构造函数，属性和方法等，Java 允许用户借由这个 Class 相关的元信息对象间接调用 Class 对象的功能。


## JVM是如何工作的？

JVM 分为三个主要的子系统：
1. 类加载器子系统
2. 运行时数据区
3. 执行引擎

### 1、类加载器子系统
> Java的动态类加载功能是由类加载器子系统处理的。它负责加载、链接，并且在运行时首次引用类的时候初始化类，而不是在编译期间

1.1 加载
> 这个组件负责加载类。BootStrap类加载器、Extension类加载器和Application类加载器是实现这个功能的三大类加载器。

* BootStrap类加载器 ——称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库
* Extension类加载器 —— 称为扩展类加载器，负责加载Java的扩展类库，默认加载`JAVA_HOME/jre/lib/ext/`目下的所有jar
* Application类加载器 —— 称为系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件。

ClassLoader加载类的原理
> 双亲委派模型
* 如果一个类加载器收到类加载的请求
* 它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。
* 每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载

> 为什么用双亲委派

java虚拟机只会在不同的类的类名相同且加载该类的加载器均相同的情况下才会判定这是一个类。
* 如果没有双亲委派机制，同一个类可能就会被多个类加载器加载，如此类就可能会被识别为两个不同的类，相互赋值时问题就会出现。
* 双亲委派机制能够保证多加载器加载某个类时，最终都是由一个加载器加载，确保最终加载结果相同


> "父加载器"和"子加载器"之间的关系是继承的吗？
* 很多人看到父加载器、子加载器这样的名字，就会认为Java中的类加载器之间存在着继承关系。
* 这里需要明确一下，双亲委派模型中，类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码的。

> 双亲委派是怎么实现的？

实现双亲委派模型的代码都集中在 java.lang.ClassLoader 的 loadClass() 
1. 首先检查这个类是否已经被加载过了（是否在虚拟机中已经存在了），若已经加载了，就直接进返回。
2. 若没有加载，则调用父类加载器的 loadClass() 方法去尝试加载。
3. class loader如父类加载器为空，则使用启动类加载器去尝试加载。
4. 如果父类加载器加载失败，则抛出 ClassNotFoundException 异常后，使用自己的 findClass() 方法进行加载。

> 为什么重写loadClass方法可以破坏双亲委派，这个方法和findClass()、defineClass()区别是什么
```
因为他的双亲委派过程都是在loadClass方法中实现的，那么想要破坏这种机制，那么就自定义一个类加载器，重写其中的loadClass方法，使其不进行双亲委派即可。
```

* loadClass() ->就是主要进行类加载的方法，默认的双亲委派机制就实现在这个方法中。
* definclass(): 把字节码转化为Class
* findClass(): 根据名称或位置加载.class字节码,然后使用defineClass
```
如果你想定义一个自己的类加载器，并且要遵守双亲委派模型，那么可以继承ClassLoader，并且在findClass中实现你自己的加载逻辑即可
```
> 双亲委派被破坏的例子
* 是JNDI、JDBC等需要加载SPI接口实现类的情况
* 为什么Tomcat要破坏双亲委派:
  *  一个web容器可能需要部署多个应用程序
  *  不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的
  *  如果采用默认的双亲委派类加载机制，那么是无法加载多个相同的类。
  *  所以，Tomcat破坏双亲委派原则，提供隔离的机制，为每个web容器单独提供一个WebAppClassLoader加载器

1.2 链接
1. 校验 —— 确保加载的类的正确性，如果校验失败，我们将获得校验错误信息。
2. 准备 —— 类中的静态变量分配内存，并且其初始化为默认值。
3. 解析 —— 把类中的符号引用变为直接引用。

1.3 初始化
这是类加载的最后阶段，所有的静态变量都将被分配原值，静态代码块将被执行。

### 2.运行时数据区

运行时数据区被划分为五个主要部分
* 方法区 —— 所有类级数据都将存储在这里，包括静态变量。每一个JVM只有一个方法区，并且它是一个共享资源。
* 堆区 —— 所有对象及其对应的实例变量和数组等存储在此，每个JVM只有一个堆区。由于方法区和堆区是多线程内存共享，因此存储的数据是非线程安全的。
* 栈区 —— 每个线程都会创建一个单独的运行时栈。在每一次方法调用，都会在栈内存中创建一个栈帧(Stack Frame)。所有局部变量将在栈内存中创建。栈区是线程安全的，因为它不是一个共享资源。栈帧可以被划分为三个实体：
    * 局部变量数组 —— 与方法中有多少局部变量有关，相应的值将存储在此处。 
    * 操作数栈 —— 如果任何的中间操作需要被执行，操作数栈将作为运行时工作区来执行操作。 
    * 帧数据 —— 与方法相对应的所有符号存储在此。在任何异常情况下，catch块的信息被保留在帧数据中。
* PC寄存器(Program Counter Register) —— 每一个线程都有单独的PC寄存器，一旦执行指令，PC寄存器将被下一条指令更新，保存当前执行指令的地址。
* 本地方法栈 —— 本地方法栈保存本地方法信息，每一个线程都会创建一个单独的本地方栈。

### 3、执行引擎
> 分配到运行时数据区的字节码将被执行引擎执行。执行引擎读取字节码并逐一执行

Java本地接口（JNI）：JNI与本地方法库交互，并为执行引擎提供本地方法库。

本地方法库（Native Method Libraries）：它是执行引擎所需的本地库集合

## 运行时数据区域(内存模型)

<img width="343" alt="Screen Shot 2021-11-08 at 5 52 53 PM" src="https://user-images.githubusercontent.com/27160394/140720883-7c40f4d4-fad6-44db-8740-6893074a16f3.png">

1. 程序计数器（线程私有）
> 记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。
* 多个线程竞争时被挂起，程序计数器记录执行到哪里
* 唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域

2. 虚拟机栈(线程私有)
> 每个Java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息，从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程
该区域可能抛出以下异常：
* 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；
* 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。

3. 本地方法栈(线程私有)
> 本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理
* 本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务

4. 堆
> 所有对象实例都在这里分配内存

* 是垃圾收集的主要区域("GC 堆").
* 现代的垃圾收集器基本都是采用分代收集算法（因为对象的生命周期不一样），主要思想是针对不同的对象采取不同的垃圾回收算法

虚拟机把 Java 堆分成以下三块：
* 新生代(Young Generation): 在方法中去 new 一个对象，那这方法调用完毕后，对象就会被回收，这就是一个典型的新生代对象
* 老年代(Old Generation): 在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。而且大对象直接进入老年代,当 Survivor 空间不够用时，需要依赖于老年代进行分配担保，所以大对象直接进入老年代
* 永久代(Permanent Generation):即方法区。

新生代存放着大量的生命很短的对象，因此新生代在三个区域中垃圾回收的频率最高。为了更高效地进行垃圾回收，把新生代继续划分成以下三个空间：

* Eden（伊甸园）
* From Survivor（幸存者）
* To Survivor

可以通过`-Xms`和`-Xmx`两个虚拟机参数来指定一个程序的 Java 堆内存大小，第一个参数设置初始值，第二个参数设置最大值
```
java -Xms=1M -Xmx=2M HackTheJava
```
5. 方法区
> 用于存放已被加载的类信息(包含：类版本、字段、方法、接口),常量(final)、静态变量 (static)、即时编译器 (JIT) 编译后的代码等数据
* 因为都是共享的数据，所有要放在方法区。
* 和 Java 堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常
* 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现

6.运行时常量池
> 运行时常量池是方法区的一部分
* Class 文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域

7. 直接内存
在 JDK 1.4 中新加入了 NIO 类
* 它可以使用Native函数库直接分配堆外内存，
* 然后通过一个存储在Java堆里的 DirectByteBuffer对象作为这块内存的引用进行操作。
* 这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

----
## 2. GC
### 判断一个对象是否可被回收
* 程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。
* 垃圾回收主要是针对Java堆和方法区进行

1.引用计数算法
* 给对象中添加一个引用计数器每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能在被使用的
* 缺陷：很难解决对象间相互循环引用的问题

2.可达性分析算法
* 通过GC Roots作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收

GC用的引用可达性分析算法中，哪些对象可作为GC Roots对象？
* 虚拟机栈(栈帧中的本地变量表)中引用的对象。
* 方法区中静态属性引用的对象。
* 方法区中常量引用的对象。
* 本地方法栈中 JNI （即一般说的 Native 方法）引用的对象。
 
### 引用类型
> 将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)4种，这4种引用强度依次逐渐减弱

1. 强引用(Strong Reference)
  * java中的引用默认
  * 被强引用关联的对象不会被回收。
  * 使用new一个新对象的方式来创建强引用。
  
2. 软引用(Soft Reference）
  * 被软引用关联的对象只有在内存不够的情况下才会被回收
  * 使用`SoftReference`类来创建软引用

3.弱引用(Weak Reference)
  * 被弱引用关联的对象一定会被回收,也就是说它只能存活到下一次垃圾回收发生之前
  * 使用`WeakReference`类来实现弱引用
  
4.虚引用(Phantom Reference)
  * 一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象
  * 为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知.跟踪垃圾回收器收集对象的活动
  * 使用`PhantomReference`来实现虚引用
 
### 方法区的回收
Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的 “性价比” 一般比较低;

永久代的垃圾收集主要回收两部分：废弃常量 和 无用的类。
* 回收废弃常量与回收 Java 堆中的对象非常类似。
* 要判定一个类是否是 “无用的类” 的条件相对苛刻许多。类需要同时满足下面3个条件才能算 “无用的类
  * 该类的所有实例都已经被回收。
  * 加载该类的 ClassLoader 已经被回收。
  * 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 垃圾收集算法（垃圾处理方法)(如何回收)
1. 标记 - 清除

首先标记出所有需要回收的对象，在标记完成后统一回收所有标记的对象
* 效率问题：标记和清除都需要遍历，效率不高；
* 空间问题：标记清除之后会产生大量不连续的内存碎片，导致以后需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另外一次垃圾收集

2.标记 - 整理
* 标记过程仍然与"标记-清除"算法一样，
* 但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存
* 无需复制，保证效率。内存规整。
* 效率不如复制算法

3. 复制回收
* 将内存划分为大小相等的两块，每次只使用其中一块
* 当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理
* 简答高效，内存相对整齐
* 主要不足是只使用了内存的一半。
* .如果对象存活率高，需要复制的对象比较多，产生效率问题。

优化: 现在的商业虚拟机都采用这种收集算法来回收新生代
* 我们可以把内存划分为三块：Eden、Survior1、Survior2，大小比例为 8:1:1。
* 分配内存时只使用 Eden + Survior1
* 当这里的内存将满时，JVM 会出发一次 MinorGC，清除掉废弃对象，并将存活对象复制到另一块 Survior2 中。那么接下来就使用 Eden + Survior2 进行内存分配。

4. 分代收集
* 根据对象存活周期将内存划分为几块，不同块采用适当的收集算法
* 一般将堆分为新生代和老年代
* 新生代使用：复制回收 算法
* 老年代使用：因为这些对象存活率高，没有额外空间进行分配担保, 标记 - 清除 或者 标记 - 整理 算法
----
## 垃圾收集器
* 单线程与多线程：单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；
* 串行与并行：串行指的是垃圾收集器与用户程序交替执行,这意味着在执行垃圾收集的时候需要停顿用户程序;并行指的是垃圾收集器和用户程序同时执行。除了CMS和G1之外,其它垃圾收集器都是以串行的方式执行。

<img width="488" alt="Screen Shot 2021-11-08 at 8 34 39 PM" src="https://user-images.githubusercontent.com/27160394/140743007-609d1d6f-b879-4509-9bf6-b1d5ff6fc577.png">



1.Serial
* Serial 翻译为串行，也就是说它以串行的方式执行。
* 它是单线程的收集器，只会使用一个线程进行垃圾收集工作
* 它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。
* 它是 Client 模式下的默认新生代收集器
<img width="433" alt="Screen Shot 2021-11-14 at 7 03 46 PM" src="https://user-images.githubusercontent.com/27160394/141678253-17925a7f-98b8-4d8a-983e-1908e24dfebc.png">

2.ParNew
* Serial 收集器的多线程版本
* Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作
* 所以在 JDK1.5中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个

<img width="422" alt="Screen Shot 2021-11-14 at 7 04 33 PM" src="https://user-images.githubusercontent.com/27160394/141678279-19b23aef-1e47-4945-82cd-94ddce0ab74e.png">

3.Parallel Scavenge
* Parallel Scavenge 收集器是一个新生代收集器，
* 使用复制算法的收集器，又是并行的多线程收集器
* 它的目标是达到一个可控制的吞吐量，它被称为吞吐量优先收集器.(其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间(响应时间))
* Parallel Scavenge 收集器气提供了两个参数用于精确控制吞吐量
  * 最大垃圾收集停顿时间：`-XX:MaxGCPauseMills`
  * 吞吐量大小：`-XX:GCTimeRatio`
 
```
吞吐量指 CPU 用于运行用户代码的时间占总时间的比值
吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)
停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务
缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。
```

4.Serial Old
*  Serial 收集器的老年代版本，它同样是一个单线程收集器，使用 ”标记-整理“ 算法。
*  在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用

5.Parallel Old
* Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和 ”标记-整理“ 算法
* 在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

6.CMS
* Mark Sweep指的是标记-清除算法. 
* 主要优点：并发收集、低停顿，Sun公司也称之为并发低停顿收集器（Concurrent Low Pause Collection）

<img width="509" alt="Screen Shot 2021-11-14 at 7 15 32 PM" src="https://user-images.githubusercontent.com/27160394/141678598-aafe659a-492e-4a78-aea2-aa390d8b58ba.png">

分为以下四个流程：
1. 初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要停顿。
2. 并发标记：进行GC Roots Tracing的过程，它在整个回收过程中耗时最长，不需要停顿。
3. 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
4. 并发清除：不需要停顿。

缺点
* 吞吐量低: 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高.
* 标记-清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC
* 无法处理浮动垃圾，指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收
* 由于浮动垃圾的存在，因此需要预留出一部分内存,如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。

7.G1
oracle 官方计划在 jdk9 中将 G1 变成默认的垃圾收集器
* G1的设计原则就是简单可行的性能调优
* G1将新生代,老年代的物理空间划分取消了
* G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离
  * 从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能
* 并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region
* 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描

<img width="596" alt="Screen Shot 2021-11-14 at 7 27 27 PM" src="https://user-images.githubusercontent.com/27160394/141678922-0847b74e-4c25-482d-bb16-d9fe9e216bbf.png">

过程
1. 初始标记： 这个阶段是STW(Stop the World )的，所有应用线程会被暂停，标记出从GC Root开始直接可达的对象
2. 并发标记： 从GC Roots开始对堆中对象进行可达性分析，找出存活对象，耗时较长。
3. 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
4. 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

优点
* 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。
* 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。
---
### 内存分配与回收策略

**Minor GC，Full GC**
* Minor GC：发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。
  * 新生代中的垃圾收集动作，采用的是复制算法
  * 对于较大的对象，在 Minor GC 的时候可以直接进入老年代
* Full GC：发生在老年代上，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多
  * Full GC 是发生在老年代的垃圾收集动作，采用的是 标记-清除/整理 算法。
  * 由于老年代的对象几乎都是在 Survivor 区熬过来的，不会那么容易死掉。因此 Full GC 发生的次数不会有 Minor GC 那么频繁，
  *  Time(Full GC)>Time(Minor GC)


**内存分配策略**
1. 对象优先在 Eden 分配
2. 对象直接进入老年代(需要连续内存空间的对象)
3. 长期存活的对象进入老年代
4. 动态对象年龄判定: 如果在Survivor中相同年龄所有对象大小的总和大于Survivor空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代,无需等到 MaxTenuringThreshold 中要求的年龄
5. 空间分配担保: 在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。
  * 如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败,如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小
  * 如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。


**Full GC 的触发条件**
> 对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂
1.`System.gc()`:只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存
2.老年代空间不足: 可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代
3.使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC
4.Concurrent Mode Failure:执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足(可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足)，便会报 Concurrent Mode Failure 错误，并触发 Full GC
---
## 3. 类加载机制
> 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机类加载机制

类的生命周期
<img width="450" alt="Screen Shot 2021-11-14 at 7 48 03 PM" src="https://user-images.githubusercontent.com/27160394/141679513-e7c153f5-386e-4c25-85c8-59d2dab6c037.png">
1. 加载（Loading）
2. 验证（Verification）
3. 准备（Preparation）
4  解析（Resolution）
5. 初始化（Initialization）
6. 使用（Using）
7. 卸载（Unloading）
 
### 类初始化时机

1.主动引用: 虚拟机规范严格规定了有且只有下列五种情况必须对类进行初始化(加载、验证、准备都会随之发生)
 * 遇到`new、getstatic、putstatic、invokestatic`这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。
   * 最常见的生成这4条指令的场景是：`new`实例化对象的时候,读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。
 * 使用`java.lang.reflect`包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化 
 * 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
 * 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类
 * 如果`java.lang.invoke.MethodHandle`实例最后的解析结果为`REF_getStatic, REF_putStatic,REF_invokeStatic`的方法，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化

2.被动引用:以上5种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用
 * 通过子类引用父类的静态字段，不会导致子类初始化
 * 通过数组定义来引用类，不会触发此类的初始化
 * 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化


### 类加载过程

绑定：一个方法的调用与方法所在的类关联起来
* 静态绑定：即前期绑定。在程序执行前方法已经被绑定，由编译器实现。java当中的方法只有final，static，private和构造方法是前期绑定的。
* 动态绑定：运行时的绑定，运行时根据具体对象的类型进行绑定。

**1.加载**
> 加载过程完成以下三件事
1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构
3. 在Java堆中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口

对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在就Java虚拟机中的唯一性，也就是说，即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的`equals(),isAssignableFrom(),isInstance()`等方法的返回结果

**2. 验证**
> 确保`Class`文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全

1. 文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。
2. 元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。
3. 字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。
4. 符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。

**3.准备**
* 正式为类变量分配内存并设置变量的初始值。
* 这些变量使用的内存都将在方法区中进行分配。
* 类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存
* 实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在堆
* 实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次
* 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值


**4.解析**
> 虚拟机将常量池的符号引用替换为直接引用的过程
* 类或接口的解析
* 字段解析
* 类方法解析
* 接口方法解析

*符号引用和直接引用？*

* 符号引用：符号引用是一组符号来描述所引用的目标对象，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标对象并不一定已经加载到内存中
* 直接引用：直接引用可以是直接指向目标对象的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机内存布局实现相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同，如果有了直接引用，那引用的目标必定已经在内存中存在。

符号引用就是字符串,这个字符串包含足够的信息,以供实际使用时可以找到相应的位置


**5. 初始化**
> 初始化阶段才真正开始执行类中定义的Java程序代码。初始化阶段即虚拟机执行类构造器`<clinit>()`方法的过程。

在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。

`<clinit>()`方法的执行规则:
* 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。
* 与类的构造函数（或者说实例构造器 <init>()）不同，不需要显式的调用父类的构造器。虚拟机会自动保证在子类的`<clinit>()`方法运行之前，父类的`<clinit>()`方法已经执行结束。因此虚拟机中第一个执行 <clinit>() 方法的类肯定为 java.lang.Object。
* 由于父类的`<clinit>()`方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。
* `<clinit>()` 方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成 <clinit>() 方法。
* 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 `<clinit>()`方法。但接口与类不同的是，执行接口的`<clinit>() ]`方法不需要先执行父接口的 <clinit>() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <clinit>() 方法。
 * 虚拟机会保证一个类的`<clinit>()`方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的`<clinit>()`方法，其它线程都会阻塞等待，直到活动线程执行 `<clinit>()`方法完毕。如果在一个类的 <clinit>() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。
 
 
 ### 类加载器
 > 虚拟机设计团队把类加载阶段中的"获取描述此类的二进制字节流”放到 Java 虚拟机外部去实现,以便让应用程序自己决定如何去获取所需要的类.实现这个动作的代码模块称为 “类加载器”
 
 类与类加载器
 * 两个类相等：只有被同一个类加载器加载的类才可能会相等。相同的字节码被不同的类加载器加载的类不相等。
 
**类加载器分类**
从 Java 虚拟机的角度来讲
* 启动类加载器（Bootstrap ClassLoader），这个类加载器用 C++ 实现，是虚拟机自身的一部分
* 所有其他类的加载器，这些类由 Java 实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。
 

从 Java 开发人员的角度看
* 启动类加载器（Bootstrap ClassLoader): 是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库
  * 此类加载器负责将存放在 <JAVA_HOME>\lib 目录中的
  * 启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可
* 扩展类加载器（Extension ClassLoader):负责加载Java的扩展类库，默认加载`JAVA_HOME/jre/lib/ext/`目下的所有jar
  * 它负责将 <JAVA_HOME>/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中
  * 开发者可以直接使用扩展类加载器
* 应用程序类加载器（Application ClassLoader):负责加载应用程序classpath目录下的所有jar和class文件。
  * 它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器
* 自定义类加载器
  * 载器步骤：
    1.定义一个类，继承 ClassLoader
    2.重写 loadClass 方法
    3.实例化 Class 对象
  * 自定义类加载器的优势: 高度的灵活性,通过自定义类加载器可以实现热部署,代码加密
 
**双亲委派模型**
>为什么要使用双亲委派模型？-> 主要是为了避免重复加载的问题
 
双亲委派概念
* 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，
* 因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载
 
如果加载同一个类，该使用哪一个类？
* 父类的
 
####`Student s = new Student();`在内存中做了哪些事情
1. 加载 Student.class 文件进内存
2. 在栈内存为 s 开辟空间
3. 在堆内存为 Student 对象开辟空间
4. 对Student 对象的成员变量进行默认初始化
5. 对Student 对象的成员变量进行显示初始化
6. 通过构造方法对 Student 对象的成员变量赋值
7, Student 对象初始化完毕，把对象地址赋值给 s 变量
---
# 高频面试题

* JVM GC
* 算法
* JVM内存模型，java内存模型，及jvm内存分区，各有存了什么
* JVM内存结构
* .jvm类的加载过程
* 类加载机制
* JVM内存结构和Java反射机制体现在Spring中哪些方面
* 进程被分配了什么，进程拥有什么
* 强引用对象什么时候会被回收？
对象要和强引用没有关联
1. obj作为强引用存在虚拟机栈中,而new Object()作为对象存在于堆中
2. 当obj的作用域结束,对应的虚拟机栈消失，obj引用也同时消失, 
3. new Object()和它的关联也就断了，这样就不再和GC Roots相连接，gc在之后的某个时间就会回收这个对象了
* Java引用类型说一下
* 运行时数据区服务器使用的什么垃圾收集器CMS 
* 垃圾收集的原理G1 
* 垃圾收集的特点，
* 为什么低延迟有哪些垃圾回收算法，优缺点
* 哪些对象可以作为 GC Roots
* 有哪些类加载器双亲委派模式，
* 哪些场景是打破双亲委派模式线上服务器出现频繁 Full GC，
* 怎么排查定位问题常用哪些命令
* 介绍下JVM 调优的过程
