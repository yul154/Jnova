


# 框架
## 1. JVM框架
> JVM 基本结构
* 类加载器
* 执行引擎
* 运行时数据区
* 本地接口

Class Files -> ClassLoader -> 运行时数据区 -> 执行引擎，本地库接口 -> 本地方法库

### JVM体系结构
<img width="509" alt="Screen Shot 2021-11-08 at 5 02 15 PM" src="https://user-images.githubusercontent.com/27160394/140713405-b15c174b-2d32-4bc3-85b1-1dfd9ed0785b.png">

### JVM各个模块

* 运行时数据区 : 经过编译生成的字节码文件（class文件），由 class loader（类加载子系统）加载后交给执行引擎执行。在执行引擎执行的过程中产生的数据会存储在一块内存区域。这块内存区域就是运行时区域
* 程序计数器 : 用于记录当前线程的正在执行的字节码指令位置,不同线程的执行位置都需要记录下来，因此程序计数器是线程私有的
* 虚拟机栈: 虚拟机栈是 Java 方法执行的内存结构，虚拟机会在每个 Java 方法执行时创建一个“栈桢,当方法执行完毕时，该栈桢会从虚拟机栈中出栈。其中局部变量表包含基本数据类型和对象引用
  * 在 Java 虚拟机规范中，对这个区域规定了两种异常状态：
  * 如果线程请求的栈的深度大于虚拟机允许的深度，将抛出 StackOverFlowError 异常（栈溢出）
  * 如果虚拟机栈可以动态扩展(现在大部分 Java 虚拟机都可以动态扩展，只不过 Java 虚拟机规范中也允许固定长度的 Java 虚拟机栈),如果扩展时无法申请到足够的内存空间，就会抛出 OutOfmMemoryError 异常(没有足够的内存） 
* 本地方法栈(native method stack )：类似 Java 方法的执行有虚拟机栈，执行的是Native(一个Java调用非Java代码的接囗)方法服务
* 方法区(Method area)：运行时常量池,用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。线程共享（看存储的数据就知道了）
* 堆(Heap):堆的主要作用是存放程序运行过程中创建的对象实例，
  * 因为要存放的对象实例有可能会极多，因此也是虚拟机内存管理中最大的一块。
  * 并且由于硬件条件有限，所以需要不断回收已“无用”的实例对象来腾出空间给新生成的实例对象；
  * 因此 Java 的垃圾回收主要是针对堆进行回收的（还有方法区的常量池），Java 堆很多时候也被称为GC堆（Garbage Collected Heap）
* 类加载机制(Class Loader)：类加载子系统是根据一个类的全限定名来加载该类的二进制流到内存中(动态加载class文件到内存当中用的)
  * 在JVM中将形成一份描述Class结构的元信息对象(方法区)
  * 通过该元信息对象可以获知Class的结构信息：如构造函数，属性和方法等，Java 允许用户借由这个 Class 相关的元信息对象间接调用 Class 对象的功能。


### JVM是如何工作的？

JVM 分为三个主要的子系统：
1. 类加载器子系统
2. 运行时数据区
3. 执行引擎

#### 1、类加载器子系统
> Java的动态类加载功能是由类加载器子系统处理的。它负责加载、链接，并且在运行时首次引用类的时候初始化类，而不是在编译期间

1.1 加载
> 这个组件负责加载类。BootStrap类加载器、Extension类加载器和Application类加载器是实现这个功能的三大类加载器。

* BootStrap类加载器 ——称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库
* Extension类加载器 —— 称为扩展类加载器，负责加载Java的扩展类库，默认加载`JAVA_HOME/jre/lib/ext/`目下的所有jar
* Application类加载器 —— 称为系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件。

ClassLoader加载类的原理

双亲委派模型
* 如果一个类加载器收到类加载的请求
* 它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。
* 每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载

1.2 链接
1. 校验 —— 确保加载的类的正确性，如果校验失败，我们将获得校验错误信息。
2. 准备 —— 类中的静态变量分配内存，并且其初始化为默认值。
3. 解析 —— 把类中的符号引用变为直接引用。

1.3 初始化

这是类加载的最后阶段，所有的静态变量都将被分配原值，静态代码块将被执行。

#### 2.运行时数据区

运行时数据区被划分为五个主要部分
* 方法区 —— 所有类级数据都将存储在这里，包括静态变量。每一个JVM只有一个方法区，并且它是一个共享资源。
* 堆区 —— 所有对象及其对应的实例变量和数组等存储在此，每个JVM同样只有一个堆区。由于方法区和堆区是多线程内存共享，因此存储的数据是非线程安全的。
* 栈区 —— 每个线程都会创建一个单独的运行时栈。在每一次方法调用，都会在栈内存中创建一个栈帧(Stack Frame)。所有局部变量将在栈内存中创建。栈区是线程安全的，因为它不是一个共享资源。栈帧可以被划分为三个实体：
    * 局部变量数组 —— 与方法中有多少局部变量有关，相应的值将存储在此处。 
    * 操作数栈 —— 如果任何的中间操作需要被执行，操作数栈将作为运行时工作区来执行操作。 
    * 帧数据 —— 与方法相对应的所有符号存储在此。在任何异常情况下，catch块的信息被保留在帧数据中。
* PC寄存器(Program Counter Register) —— 每一个线程都有单独的PC寄存器，一旦执行指令，PC寄存器将被下一条指令更新，保存当前执行指令的地址。
* 本地方法栈 —— 本地方法栈保存本地方法信息，每一个线程都会创建一个单独的本地方栈。

#### 3、执行引擎
> 分配到运行时数据区的字节码将被执行引擎执行。执行引擎读取字节码并逐一执行


Java本地接口（JNI）：JNI与本地方法库交互，并为执行引擎提供本地方法库。

本地方法库（Native Method Libraries）：它是执行引擎所需的本地库集合

### 运行时数据区域(内存模型)

<img width="343" alt="Screen Shot 2021-11-08 at 5 52 53 PM" src="https://user-images.githubusercontent.com/27160394/140720883-7c40f4d4-fad6-44db-8740-6893074a16f3.png">

1. 程序计数器（线程私有）
> 记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。
* 多个线程竞争时被挂起，程序计数器记录执行到哪里
* 唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域

2. 虚拟机栈(线程私有)
> 每个Java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息，从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程
该区域可能抛出以下异常：
* 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；
* 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。

3. 本地方法栈(线程私有)
> 本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理
* 本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务

4. 堆
> 所有对象实例都在这里分配内存

* 是垃圾收集的主要区域("GC 堆").
* 现代的垃圾收集器基本都是采用分代收集算法（因为对象的生命周期不一样），主要思想是针对不同的对象采取不同的垃圾回收算法

虚拟机把 Java 堆分成以下三块：
* 新生代(Young Generation): 在方法中去 new 一个对象，那这方法调用完毕后，对象就会被回收，这就是一个典型的新生代对象
* 老年代(Old Generation): 在新生代中经历了 N 次垃圾回收后仍然存活的对象就会被放到老年代中。而且大对象直接进入老年代,当 Survivor 空间不够用时，需要依赖于老年代进行分配担保，所以大对象直接进入老年代
* 永久代(Permanent Generation):即方法区。

新生代存放着大量的生命很短的对象，因此新生代在三个区域中垃圾回收的频率最高。为了更高效地进行垃圾回收，把新生代继续划分成以下三个空间：

* Eden（伊甸园）
* From Survivor（幸存者）
* To Survivor


5. 方法区
> 用于存放已被加载的类信息(包含：类版本、字段、方法、接口),常量(final)、静态变量 (static)、即时编译器 (JIT) 编译后的代码等数据
* 因为都是共享的数据，所有要放在方法区。
* 和 Java 堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常
* 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现

6.运行时常量池
> 运行时常量池是方法区的一部分
* Class 文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域

7. 直接内存
在 JDK 1.4 中新加入了 NIO 类
* 它可以使用Native函数库直接分配堆外内存，
* 然后通过一个存储在Java堆里的 DirectByteBuffer对象作为这块内存的引用进行操作。
* 这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

----
## 2. GC

### 判断一个对象是否可被回收
* 程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。
* 垃圾回收主要是针对Java堆和方法区进行

1.引用计数算法
* 给对象中添加一个引用计数器每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能在被使用的
* 缺陷：很难解决对象间相互循环引用的问题

2.可达性分析算法
* 通过GC Roots作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收

GC用的引用可达性分析算法中，哪些对象可作为GC Roots对象？
* 虚拟机栈(栈帧中的本地变量表)中引用的对象。
* 方法区中静态属性引用的对象。
* 方法区中常量引用的对象。
* 本地方法栈中 JNI （即一般说的 Native 方法）引用的对象。
 
### 引用类型
> 将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)4种，这4种引用强度依次逐渐减弱

1. 强引用(Strong Reference)
  * java中的引用默认
  * 被强引用关联的对象不会被回收。
  * 使用new一个新对象的方式来创建强引用。
  
2. 软引用(Soft Reference）
  * 被软引用关联的对象只有在内存不够的情况下才会被回收
  * 使用`SoftReference`类来创建软引用

3.弱引用(Weak Reference)
  * 被弱引用关联的对象一定会被回收,也就是说它只能存活到下一次垃圾回收发生之前
  * 使用 WeakReference 类来实现弱引用
  
4.虚引用(Phantom Reference)
  * 为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知.跟踪垃圾回收器收集对象的活动
  * 一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象
  * 为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。
  * 使用 PhantomReference 来实现虚引用
 
### 方法区的回收
Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的 “性价比” 一般比较低;而永久代的垃圾收集效率远低于此。

永久代的垃圾收集主要回收两部分：废弃常量 和 无用的类。
* 回收废弃常量与回收 Java 堆中的对象非常类似。
* 要判定一个类是否是 “无用的类” 的条件相对苛刻许多。类需要同时满足下面3个条件才能算 “无用的类
  * 该类的所有实例都已经被回收。
  * 加载该类的 ClassLoader 已经被回收。
  * 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 垃圾收集算法（垃圾处理方法)(如何回收)
1. 标记 - 清除

首先标记出所有需要回收的对象，在标记完成后统一回收所有标记的对象
* 效率问题：标记和清除都需要遍历，效率不高；
* 空间问题：标记清除之后会产生大量不连续的内存碎片，导致以后需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另外一次垃圾收集

2.标记 - 整理
* 标记过程仍然与"标记-清除"算法一样，
* 但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存
* 无需复制，保证效率。内存规整。
* 效率不如复制算法

3. 复制回收
* 将内存划分为大小相等的两块，每次只使用其中一块
* 当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理
* 简答高效，内存相对整齐
* 主要不足是只使用了内存的一半。
* .如果对象存活率高，需要复制的对象比较多，产生效率问题。

优化: 现在的商业虚拟机都采用这种收集算法来回收新生代
* 我们可以把内存划分为三块：Eden、Survior1、Survior2，大小比例为 8:1:1。
* 分配内存时只使用 Eden + Survior1
* 当这里的内存将满时，JVM 会出发一次 MinorGC，清除掉废弃对象，并将存活对象复制到另一块 Survior2 中。那么接下来就使用 Eden + Survior2 进行内存分配。

4. 分代收集
* 根据对象存活周期将内存划分为几块，不同块采用适当的收集算法
* 一般将堆分为新生代和老年代
* 新生代使用：复制回收 算法
* 老年代使用：因为这些对象存活率高，没有额外空间进行分配担保, 标记 - 清除 或者 标记 - 整理 算法


### 垃圾收集器
* 单线程与多线程：单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；
* 串行与并行：串行指的是垃圾收集器与用户程序交替执行,这意味着在执行垃圾收集的时候需要停顿用户程序;并形指的是垃圾收集器和用户程序同时执行。除了CMS和G1之外,其它垃圾收集器都是以串行的方式执行。

<img width="488" alt="Screen Shot 2021-11-08 at 8 34 39 PM" src="https://user-images.githubusercontent.com/27160394/140743007-609d1d6f-b879-4509-9bf6-b1d5ff6fc577.png">

1.Serial
* Serial 翻译为串行，也就是说它以串行的方式执行。
* 它是单线程的收集器，只会使用一个线程进行垃圾收集工作
* 它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。

2.ParNew
* Serial 收集器的多线程版本
* 只有它能与 CMS 收集器配合工作
* 所以在 JDK1.5中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个

3.Parallel Scavenge
* Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器
* 它的目标是达到一个可控制的吞吐量，它被称为吞吐量优先收集器。

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务


4.Serial Old
*  Serial 收集器的老年代版本，它同样是一个单线程收集器，使用 ”标记-整理“ 算法。
*  在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用

5.Parallel Old
* Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和 ”标记-整理“ 算法
* 在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

6.CMS
* Mark Sweep指的是标记-清除算法. 
* 主要优点：并发收集、低停顿，Sun公司也称之为并发低停顿收集器（Concurrent Low Pause Collection）
* 

分为以下四个流程：
1. 初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要停顿。
2. 并发标记：进行GC Roots Tracing的过程，它在整个回收过程中耗时最长，不需要停顿。
3. 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
4. 并发清除：不需要停顿。

缺点
* 吞吐量低: 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高.
* 标记-清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC
* 无法处理浮动垃圾，指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收
* 由于浮动垃圾的存在，因此需要预留出一部分内存

7.G1
oracle 官方计划在 jdk9 中将 G1 变成默认的垃圾收集器
* G1的设计原则就是简单可行的性能调优
* G1将新生代，老年代的物理空间划分取消了
* G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离
* 从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能
* 并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region

每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描

过程
1. 初始标记
2. 并发标记
3. 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
4. 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

优点
* 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。
* 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。

## 3. 类加载机制

# 高频面试题

* JVM GC
* 算法
* JVM内存模型，java内存模型，及jvm内存分区，各有存了什么
* JVM内存结构
* .jvm类的加载过程
* 类加载机制
* JVM内存结构和Java反射机制体现在Spring中哪些方面
* 进程被分配了什么，进程拥有什么
* 强引用对象什么时候会被回收？
对象要和强引用没有关联
1. obj作为强引用存在虚拟机栈中,而new Object()作为对象存在于堆中
2. 当obj的作用域结束,对应的虚拟机栈消失，obj引用也同时消失, 
3. new Object()和它的关联也就断了，这样就不再和GC Roots相连接，gc在之后的某个时间就会回收这个对象了
* Java引用类型说一下
* 运行时数据区服务器使用的什么垃圾收集器CMS 
* 垃圾收集的原理G1 
* 垃圾收集的特点，
* 为什么低延迟有哪些垃圾回收算法，优缺点
* 哪些对象可以作为 GC Roots
* 有哪些类加载器双亲委派模式，
* 哪些场景是打破双亲委派模式线上服务器出现频繁 Full GC，
* 怎么排查定位问题常用哪些命令
* 介绍下JVM 调优的过程
